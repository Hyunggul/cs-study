# InnoDB 클러스터

<br>

소스 서버에서 장애가 발생했을 때 레플리카 서버가 자동으로 기존 소스 서버를 대체하는 것이 아님

서버 자체적으로 Failover를 처리하는 기능을 제공하지 않으므로 사용자는 장애가 발생했을 때 레플리카 서버가 새로운 소스 서버가 될 수 있도록 작업 필요

1. 레플리카 서버에 설정된 읽기 모드를 해제
2. 스플릿 브레인 현상을 방지하기 위해 장애가 발생한 소스 서버에서 데이터 변경을 못하게
3. 애플리케이션 서버는 새로운 소스 서버를 바라보도록 커넥션 설정

이같은 전환 작업을 수동으로 처리하기보다 자동화를 고려

빌트인 HA 솔루션인 InnoDB 클러스터 도입


### InnoDB 클러스터 아키텍처

MySQL의 고가용성 실현을 위해 만들어진 여러 구성 요소들의 집합체

그룹 복제, MySQL 라우터, MySQL 셸

<p align="center"><img src="./images/17_1.png" width="30%"></p>

<br>

InnoDB 클러스터에서 데이터가 저장되는 MySQL 서버들은 그룹 복제 형태로 복제가 구성되며 각 서버는 Read/Write가 모두 가능한 프라이머리 혹은 Read만 가능한 세컨더리 중 하나의 역할로 동작

여기서 프라이머리는 기존 MySQL 복제에서의 소스 서버

세컨더리는 레플리카 서버

<br>

그룹복제에서는 InnoDB 스토리지 엔진만 사용 가능

그룹 복제를 구성할 때 고가용성을 위해 최소 3대 이상 구성

3대로 구성했을 때부터 MySQL 서버 한 대에 장애가 발생하더라도 복제 그룹이 정상적으로 작동

InnoDB 클러스터를 사용하는 환경에서 클라이언트는 MySQL 서버로 직접 접근해서 쿼리를 실행하는 것이 아니라 MySQL 라우터에 연결해서 쿼리를 실행 

<br>

라우터는 사용하는 이유는?

라우터가 MySQL 서버에 대한 메타데이터 정보를 가지고 있고, 이것을 바탕으로 쿼리들을 적절한 서버로 전달함

그래서 클라이언트는 어떤 서버로 구성돼 있는지 알고 있을 필요가 없고 커넥션 정보에 라우터 서버만 설정해두면 됨

MySQL 셸은 사용자가 손쉽게 InnoDB 클러스터를 생성하고 관리할 수 있도록 API를 제공

`InnoDB 클러스터에서는 MySQL 서버에 장애가 생기면 그룹 복제가 이를 먼저 감지해서 자동으로 해당 서버를 복제 그룹에서 제외`

`MySQL 라우터는 변경된 토폴로지를 인지하고 메타 데이터를 갱신해서 쿼리를 정상 작동하는 MySQL 서버로만 전달될 수 있도록`

서버 고가용성을 위해 InnoDB 클러스터만 사용하면 됨

<br>

### 그룹 복제

기존 MySQL 복제 프레임워크를 기반으로 구현 Row 포맷의 바이너리 로그(변경된 데이터 자체를 기록)

릴레이 로그(레플리카 서버가 소스 서버의 바이너리 로그를 복사)

GTID(글로벌 트랜잭션 ID)

<br>

**기존 복제와의 다른점**

소스-레플리카 형태로 구성되어 단방향 복제가 이뤄지는 반면

그룹 복제는 복제에 참여하는 서버들이 하나의 복제 그룹으로 묶인 클러스터 형태를 가짐

서로 통신하며 양방향 복제 처리

<br>

**즉, 하나의 복제 그룹 내에서 쓰기를 처리하는 서버가 여러 대 존재할 수 있음**

소스 → 프라이머리

레플리카 → 세컨더리(읽기 전용 동작)

<p align="center"><img src="./images/17_2.png" width="40%"></p>

<p align="center"><img src="./images/17_3.png" width="60%"></p>

<br>

그룹 복제는 반동기 방식

그렇다고 해서 기존 반동기와 동일한 방식으로 처리되지 않음

그룹 복제는 한 서버에서 트랜잭션이 커밋될 준비가 되면 트랜잭션 정보를 그룹의 다른 멤버들에 전송하고

과반수 이상의 멤버로부터 응답을 전달받으면 해당 트랜잭션을 인증(certify)하고 최종 커밋 처리 완료

그룹 내 멤버들의 응답에 따라 트랜잭션 적용 여부가 결정

→ 이 과정을 합의라고 하고 매 트랜잭션을 처리할 때(데이터 변경 작업)마다 이 과정을 반드시 거침

그룹 복제는 InnoDB 클러스터의 핵심 구성 요소로 반드시 이해

### 그룹 복제 아키텍처

그룹 복제는 별도 플러그인으로 구현

<details>
<summary>MySQL이 플러그인 구조인 이유</summary>

<br>

    
MySQL이 플러그인식으로 작동하는 이유는 확장성과 유연성을 높이기 위해서입니다. 플러그인 구조를 사용하면 새로운 기능이나 서비스들을 추가할 때 MySQL 서버의 핵심 코드를 수정할 필요 없이 간단히 플러그인만 설치하면 됩니다. 이를 통해 사용자와 개발자는 특정 요구에 맞는 기능을 쉽게 구현하고, MySQL 서버의 안정성과 성능을 유지할 수 있습니다. 아래는 이 개념을 쉽게 이해할 수 있도록 설명하겠습니다.

### 1. 플러그인 구조란?

플러그인 구조는 소프트웨어가 다양한 기능을 독립적으로 추가하거나 제거할 수 있도록 설계된 시스템입니다. 이를 통해 소프트웨어는 기본 기능 외에 다양한 확장 기능을 제공할 수 있습니다. 플러그인은 소프트웨어의 핵심 코드와 별도로 작동하며, 필요할 때 로드되고 사용되지 않을 때는 시스템 자원을 소모하지 않습니다.

### 2. MySQL의 플러그인 구조

MySQL의 플러그인 구조는 다음과 같은 이유로 설계되었습니다:

1. **확장성**:
    - 사용자는 기본 MySQL 서버에 없는 기능을 플러그인으로 추가할 수 있습니다. 예를 들어, 인증 메커니즘, 스토리지 엔진, 프로토콜, 사용자 정의 함수 등이 플러그인으로 제공됩니다.
    - 새로운 요구사항이 발생해도 MySQL 서버를 완전히 재설계할 필요 없이 플러그인만 개발하면 됩니다.
2. **유연성**:
    - 다양한 사용자 요구를 충족시킬 수 있습니다. MySQL을 사용하는 기업이나 개발자는 각자의 필요에 따라 다양한 플러그인을 설치하여 기능을 확장할 수 있습니다.
    - 예를 들어, 특정 보안 요구사항이 있는 경우 이를 충족시키는 플러그인을 추가할 수 있습니다.
3. **모듈화**:
    - MySQL 서버의 각 기능이 독립된 모듈로 관리되므로, 특정 모듈에 문제가 발생해도 다른 모듈에 영향을 미치지 않습니다.
    - 문제 발생 시 해당 플러그인을 업데이트하거나 교체하는 것만으로 문제를 해결할 수 있습니다.
4. **성능 최적화**:
    - 불필요한 기능을 로드하지 않음으로써 서버 성능을 최적화할 수 있습니다. 필요한 플러그인만 로드하여 사용하면 메모리와 CPU 자원을 효율적으로 사용할 수 있습니다.

### 3. 플러그인의 예

MySQL에서는 여러 유형의 플러그인이 사용됩니다. 주요 예는 다음과 같습니다:

1. **스토리지 엔진 플러그인**:
    - InnoDB, MyISAM, Memory 등 다양한 스토리지 엔진이 플러그인 형태로 제공됩니다. 사용자는 데이터 저장 방식과 성능 요구사항에 따라 적절한 스토리지 엔진을 선택할 수 있습니다.
    
    ```sql
    INSTALL PLUGIN my_plugin SONAME 'ha_my_plugin.so';
    
    ```
    
2. **인증 플러그인**:
    - MySQL은 기본적인 사용자 인증 외에도 플러그인을 통해 다양한 인증 방식을 지원합니다. LDAP, PAM, Kerberos 등을 플러그인으로 추가할 수 있습니다.
    
    ```sql
    INSTALL PLUGIN authentication_ldap_simple SONAME 'auth_ldap_simple.so';
    
    ```
    
3. **로그 플러그인**:
    - MySQL 서버의 활동을 모니터링하고 로그를 분석하기 위한 플러그인입니다. 예를 들어, 일반 쿼리 로그, 슬로우 쿼리 로그 등이 플러그인 형태로 제공될 수 있습니다.

### 4. 플러그인 설치와 관리

플러그인 설치와 관리는 간단합니다. 사용자는 필요한 플러그인을 설치하고, 설정 파일에 플러그인을 로드하도록 지정하면 됩니다. MySQL 서버는 플러그인 디렉토리에서 플러그인을 로드하고, 이를 통해 기능을 확장합니다.

```sql
-- 플러그인 설치 예시
INSTALL PLUGIN my_plugin SONAME 'my_plugin.so';

-- 플러그인 제거 예시
UNINSTALL PLUGIN my_plugin;

```

또한, MySQL 설정 파일(my.cnf 또는 my.ini)에서 플러그인을 로드하도록 설정할 수 있습니다:

```
[mysqld]
plugin-load-add=my_plugin=my_plugin.so

```

### 5. 결론

MySQL이 플러그인식으로 작동하는 이유는 다음과 같습니다:

- **확장성**: 새로운 기능을 쉽게 추가할 수 있음.
- **유연성**: 다양한 사용자 요구를 충족시킬 수 있음.
- **모듈화**: 시스템 안정성을 유지하면서 문제를 쉽게 해결할 수 있음.
- **성능 최적화**: 필요한 기능만 로드하여 시스템 자원을 효율적으로 사용함.

이러한 플러그인 구조를 통해 MySQL은 다양한 환경에서 효과적으로 사용될 수 있으며, 사용자 요구에 맞춰 쉽게 확장할 수 있는 유연한 데이터베이스 시스템으로 자리 잡았습니다.

</div>
</details>
<br>

<p align="center"><img src="./images/17_4.png" width="30%"></p>

<br>

그룹 복제에 참여하는 서버들은 그룹 복제 플러그인을 통해 서로 지속적으로 통신 → 복제 동기화

그룹 복제가 설정되면 group_relication_applier라는 복제 채널을 생성

그룹 복제 분산 복구 작업이 필요한 경우

group_replication_recovery라는 복제 채널을 생성해서 분산 복구 작업을 진행

<br>

<p align="center"><img src="./images/17_5.png" width="60%"></p>

<br>

**그룹 복제 플러그인 내부 구조**

MySQL 서버와 상호작용하기 위해 구현된 인터페이스인 플러그인 API 집합이 존재

<details>
<summary>API 존재 이유</summary>

서로 다른 시스템 간의 통신을 가능하게

예를 들어, 웹 애플리케이션이 데이터베이스와 통신하거나, 모바일 앱이 서버와 통신할 때 API를 사용

</div>
</details>
<br>

API를 통해 MySQL 서버에서 플러그인으로 혹은 그 반대로

서로 다른 시스템에서 같은 규격으로 통신하기 위해

### 그룹 복제 모드

쓰기 처리할 수 있는 프라이머리 서버 수에 따라 싱글과 멀티 프라이머리 모드로 나뉨

group_replication_single_primary_mode가 ON이면 싱글,  OFF면 멀티

**참여하려는 서버들 모두 같은 값을 가지고 있어야 함**

싱글 프라이머리 모드

쓰기를 처리할 수 있는 프라이머리 서버가 한 대만 존재하는 형태

멀티 프라이머리 모드

그룹 멤버 전부 프라이머리로 동작하는 형태

호환성을 위해 모든 멤버가 동일한 MySQL 버전으로 실행되는 것이 좋음

<br>

### MySQL 셸

단순 SQL 문만 실행 가능했던 기존 클라이언트 툴보다 확장 기능 제공

자바 스크립트와 파이썬 언어 모드

<br>

### MySQL 라우터

InnoDB 클러스터에서 애플리케이션 서버로부터 유입된 쿼리 요청을 클러스터 내 적절한 MySQL 서버로 전달하고 MySQL 서버에서 반환된 쿼리 결과를 다시 애플리케이션 서버로 전달하는 Proxy 역할을 수행

<p align="center"><img src="./images/17_6.png" width="50%"></p>

<br>

중요 기능

- InnoDB 클러스터의 MySQL 구성 변경 자동 감지
- 쿼리 부하 분산
- 자동 페일오버

MySQL 라우터 같이 중간 계층에서 프락시 역할을 하는 프로그램을 사용하지 않는 애플리케이션 서버에서는 MySQL 서버에 직접 연결해서 쿼리를 실행

애플리케이션 서버는 MySQL의 IP와 같은 정보를 커넥션 설정에 저장해서 사용하게 됨

MySQL 라우터에서는 클러스터 내 MySQL 서버 들에 대한 정보를 메모리에 캐시하고 있으며 주기적으로 이 정보를 갱신