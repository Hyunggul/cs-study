# 8장. 인덱스

인덱스는 쿼리의 성능을 언급하면서 뺴놓을 수 없는 부분

각 인덱스의 특성과 차이는 상당히 중요, 물리 수준의 모델링을 할 때에도 중요한 요소


## 디스크 읽기 방식

데이터 저장 매체(디스크)는 컴퓨터에서 가장 느린 부분

DB 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건

<br>

### 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

CPU나 메모리는 대부분 전자식 장치이지만, HDD는 기계식 장치

그래서 DB 서버에서는 항상 디스크 장치가 병목

HDD를 대체하기 위해 전자식 저장 매체 SSD가 출시

<br>

SSD는 저장용 플래터(원판)을 제거하고 플래시 메모리를 장착하고 있기에 빨리 데이터를 읽을 수 있음

<br>

<p align="center"><img src="./images/8_1.png" width="40%"></p>

<br>

`디스크 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O에서는 SSD가 HHD보다 조금 빠르거나 거의 비슷하지만, 랜덤 I/O는 훨씬 빠름`

대부분 DB 서버의 작업은 랜덤 I/O이기에 SSD는 DBMS에 최적

<br>

### 랜덤 I/O와 순차 I/O

랜덤 I/O는 HDD의 플래터를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것

<p align="center"><img src="./images/8_2.png" width="40%"></p>

<br>

해당 그림을 보면 순차 I/O는 1번 시스템 콜을 요청, 랜덤 I/O는 3번 시스템 콜을 요청

`즉, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 결정`

DB 대부분의 작업은 랜덤 I/O 작업이 빈번하기에 MySQL은 그룹 커밋, 바이너리 로그 버퍼, InnoDB 로그 버퍼 등의 기능이 내장

디스크 원판이 없는 SSD도 랜덤 I/O와 순차 I/O가 차이가 있음

<br>

일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적

`랜덤 I/O를 줄인다는 것은 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미`

인덱스 레인지 스캔은 랜덤 I/O, 풀 테이블 스캔은 순차 I/O

<br>

## 인덱스란?

칼럼의 값과 해당 레코드가 저장된 주소를 키-값 쌍으로 삼아 인덱스를 만듬

그렇기에 중요한 것이 정렬

<br>

인덱스는 SortedList, 데이터 파일은 ArrayList와 비슷

<br>

SortedList의 장단점을 통해 인덱스의 장단점 살펴보기

SortedList 자료 구조는 데이터가 저장될 때마다 값을 항상 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 빠르게 원하는 값을 찾아올 수 있음

인덱스도 마찬가지로 INSERT나 UPDATE, DELETE 문장 처리가 느리지만 SELECT는 빠름

`즉, 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 읽기 속도를 높이는 기능`

<br>

데이터 저장 방식(알고리즘)으로 분류했을 때 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분 가능

B-Tree 알고리즘

- 가장 일반적으로 사용되는 인덱스 알고리즘

- 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘

Hash 알고리즘

- 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘

- 매우 빠른 검색 지원

- 값을 변형해서 인덱싱하므로 전방 일치와 같이 값의 일부만 검색하거나 범위를 탐색할 때는 해시 탐색 불가

- 메모리 기반 데이터 베이스(Redis 등)에서 사용


<br>

데이터 중복 여부로 분류했을 때 유니크 인덱스와 유니크하지 않은 인덱스로 구분 가능

이는 옵티마이저에게 상당히 중요한 문제가 됨

유니크 인덱스에 대해서 동등 조건으로 검색하는 것은 항상 1건의 레코드를 반환하는 것이지만 유니크하지 않은 인덱스는 아님

<br>

## B-Tree 인덱스

B-Tree의 B는 Binary가 아닌 Balanced

대부분의 인덱스는 B-Tree를 사용할 정도로 일반적인 용도에 적합한 알고리즘

<br>

### 구조 및 특성

B-Tree는 트리 구조의 `최상위에 하나의 루트 노드`가 존재하고 하위에 자식 노드가 붙어 있는 형태

가장 `하위에 있는 노드를 리프 노드`라 하고 `중간 노드를 브랜치 노드`라고 함


<p align="center"><img src="./images/8_3.png" width="70%"></p>

<br>

인덱스 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 임의의 순서로 저장되어 있음

많은 사람들이 데이터 파일의 레코드는 INSERT된 순서대로 저장되는 것으로 생각하지만 그렇지 않음

레코드가 삭제되면 그 공간을 채우기 때문에 항상 INSERT된 순서로 저장되는 것은 아님

<br>

<p align="center"><img src="./images/8_4.png" width="70%"></p>

<br>

<p align="center"><img src="./images/8_5.png" width="70%"></p>

<br>

리프 노드는 레코드의 주소를 갖고 있고 그 주소로 데이터 파일에서 원하는 데이터를 찾음

InnoDB는 프라이머리 키가 ROWID 역할을 함

두 스토리지 엔진의 차이는 세컨더리 인덱스의 차이

MyISAM은 세컨더리 인덱스가 물리적 주소

InnoDB는 PK 키를 주소처럼 사용하기에 논리적 주소

<br>

8.6을 봤을 때 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색하게 됨

이것은 성능이 떨어질 것처럼 보이지만 사실은 아님

<br>

### B-Tree 인덱스 키 추가 및 삭제

테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업 발생

인덱스 키 추가나 삭제가 어떻게 처리되는지 알아보자

<br>

### 인덱스 키 추가

새로운 키 값이 B-Tree에 저장될 때, 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될수도 아닐수도 있음

B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색

<br>

저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장

리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어짐

`이런 작업 순서 탓에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 듬`

<br>

테이블에 레코드를 추가하는 작업 비용을 1이라고 가정하면,

해당 테이블의 인덱스에 키를 추가하는 작업 비용은 대충 1.5 정도로 예측

<br>

MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경

InnoDB는 지연시켜 나중에 처리할 수 있음

But, PK 키나 Unique 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제

<br>

### 인덱스 키 삭제

해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 삭제 마킹하면 작업 완료

삭제 마킹된 인덱스 키 공간은 방치하거나 재활용 가능

<br>

### 인덱스 키 변경

인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우 단순히 인덱스 상의 키 값만 변경하는 것은 불가능

키 값 삭제 -> 다시 새로운 키 값 추가

InnoDB는 체인지 버퍼를 활용해 지연 처리 가능

<br>

### 인덱스 키 검색

`빠른 검색을 위해 추가 비용을 감당하면서 인덱스를 구축`

B-Tree의 루트 노드부터 브랜치 노드, 최종 리프 노드까지 이동하면서 비교 작업을 수행하는 과정을 트리 탐색이라고 함

SELECT 뿐 아니라 UPDATE, DELETE 처리할 때도 사용

<br>

B-Tree 인덱스 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에도 사용

하지만 뒷부분만 검색하는 용도로는 X

또한 인덱스 키 값의 변형이 생긴 후 비교되는 경우에는 절대로 빠른 검색 기능을 사용할 수 없음

`따라서 함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 B-Tree의 장점을 이용할 수 없음`

<br>

InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현

따라서, UPDATE나 DELETE 문장이 실행될 때 적절히 사용할 수 있는 인덱스가 없으면 불필요한 레코드들을 잠금

그만큼 InnoDB에서는 인덱스의 설계가 중요하고 많은 부분에 영향을 미침

<br>

### B-Tree 인덱스 사용에 영향을 미치는 요소

