# 8장. 인덱스

인덱스는 쿼리의 성능을 언급하면서 뺴놓을 수 없는 부분

각 인덱스의 특성과 차이는 상당히 중요, 물리 수준의 모델링을 할 때에도 중요한 요소


## 디스크 읽기 방식

데이터 저장 매체(디스크)는 컴퓨터에서 가장 느린 부분

DB 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건

<br>

### 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

CPU나 메모리는 대부분 전자식 장치이지만, HDD는 기계식 장치

그래서 DB 서버에서는 항상 디스크 장치가 병목

HDD를 대체하기 위해 전자식 저장 매체 SSD가 출시

<br>

SSD는 저장용 플래터(원판)을 제거하고 플래시 메모리를 장착하고 있기에 빨리 데이터를 읽을 수 있음

<br>

<p align="center"><img src="./images/8_1.png" width="40%"></p>

<br>

`디스크 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O에서는 SSD가 HHD보다 조금 빠르거나 거의 비슷하지만, 랜덤 I/O는 훨씬 빠름`

대부분 DB 서버의 작업은 랜덤 I/O이기에 SSD는 DBMS에 최적

<br>

### 랜덤 I/O와 순차 I/O

랜덤 I/O는 HDD의 플래터를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것

<p align="center"><img src="./images/8_2.png" width="40%"></p>

<br>

해당 그림을 보면 순차 I/O는 1번 시스템 콜을 요청, 랜덤 I/O는 3번 시스템 콜을 요청

`즉, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 결정`

DB 대부분의 작업은 랜덤 I/O 작업이 빈번하기에 MySQL은 그룹 커밋, 바이너리 로그 버퍼, InnoDB 로그 버퍼 등의 기능이 내장

디스크 원판이 없는 SSD도 랜덤 I/O와 순차 I/O가 차이가 있음

<br>

일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적

`랜덤 I/O를 줄인다는 것은 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미`

인덱스 레인지 스캔은 랜덤 I/O, 풀 테이블 스캔은 순차 I/O

<br>

## 인덱스란?

칼럼의 값과 해당 레코드가 저장된 주소를 키-값 쌍으로 삼아 인덱스를 만듬

그렇기에 중요한 것이 정렬

<br>

인덱스는 SortedList, 데이터 파일은 ArrayList와 비슷

<br>

SortedList의 장단점을 통해 인덱스의 장단점 살펴보기

SortedList 자료 구조는 데이터가 저장될 때마다 값을 항상 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 빠르게 원하는 값을 찾아올 수 있음

인덱스도 마찬가지로 INSERT나 UPDATE, DELETE 문장 처리가 느리지만 SELECT는 빠름

`즉, 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 읽기 속도를 높이는 기능`

<br>

데이터 저장 방식(알고리즘)으로 분류했을 때 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분 가능

B-Tree 알고리즘

- 가장 일반적으로 사용되는 인덱스 알고리즘

- 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘

Hash 알고리즘

- 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘

- 매우 빠른 검색 지원

- 값을 변형해서 인덱싱하므로 전방 일치와 같이 값의 일부만 검색하거나 범위를 탐색할 때는 해시 탐색 불가

- 메모리 기반 데이터 베이스(Redis 등)에서 사용


<br>

데이터 중복 여부로 분류했을 때 유니크 인덱스와 유니크하지 않은 인덱스로 구분 가능

이는 옵티마이저에게 상당히 중요한 문제가 됨

유니크 인덱스에 대해서 동등 조건으로 검색하는 것은 항상 1건의 레코드를 반환하는 것이지만 유니크하지 않은 인덱스는 아님

<br>

## B-Tree 인덱스

B-Tree의 B는 Binary가 아닌 Balanced

대부분의 인덱스는 B-Tree를 사용할 정도로 일반적인 용도에 적합한 알고리즘

<br>

### 구조 및 특성

B-Tree는 트리 구조의 `최상위에 하나의 루트 노드`가 존재하고 하위에 자식 노드가 붙어 있는 형태

가장 `하위에 있는 노드를 리프 노드`라 하고 `중간 노드를 브랜치 노드`라고 함


<p align="center"><img src="./images/8_3.png" width="70%"></p>

<br>

인덱스 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 임의의 순서로 저장되어 있음

많은 사람들이 데이터 파일의 레코드는 INSERT된 순서대로 저장되는 것으로 생각하지만 그렇지 않음

레코드가 삭제되면 그 공간을 채우기 때문에 항상 INSERT된 순서로 저장되는 것은 아님

<br>

<p align="center"><img src="./images/8_4.png" width="70%"></p>

<br>

<p align="center"><img src="./images/8_5.png" width="70%"></p>

<br>

리프 노드는 레코드의 주소를 갖고 있고 그 주소로 데이터 파일에서 원하는 데이터를 찾음

InnoDB는 프라이머리 키가 ROWID 역할을 함

두 스토리지 엔진의 차이는 세컨더리 인덱스의 차이

MyISAM은 세컨더리 인덱스가 물리적 주소

InnoDB는 PK 키를 주소처럼 사용하기에 논리적 주소

<br>

8.6을 봤을 때 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색하게 됨

이것은 성능이 떨어질 것처럼 보이지만 사실은 아님

<br>

### B-Tree 인덱스 키 추가 및 삭제

테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업 발생

인덱스 키 추가나 삭제가 어떻게 처리되는지 알아보자

<br>

### 인덱스 키 추가

새로운 키 값이 B-Tree에 저장될 때, 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될수도 아닐수도 있음

B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색

<br>

저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장

리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어짐

`이런 작업 순서 탓에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 듬`

<br>

테이블에 레코드를 추가하는 작업 비용을 1이라고 가정하면,

해당 테이블의 인덱스에 키를 추가하는 작업 비용은 대충 1.5 정도로 예측

<br>

MyISAM이나 MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경

InnoDB는 지연시켜 나중에 처리할 수 있음

But, PK 키나 Unique 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제

<br>

### 인덱스 키 삭제

해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 삭제 마킹하면 작업 완료

삭제 마킹된 인덱스 키 공간은 방치하거나 재활용 가능

<br>

### 인덱스 키 변경

인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우 단순히 인덱스 상의 키 값만 변경하는 것은 불가능

키 값 삭제 -> 다시 새로운 키 값 추가

InnoDB는 체인지 버퍼를 활용해 지연 처리 가능

<br>

### 인덱스 키 검색

`빠른 검색을 위해 추가 비용을 감당하면서 인덱스를 구축`

B-Tree의 루트 노드부터 브랜치 노드, 최종 리프 노드까지 이동하면서 비교 작업을 수행하는 과정을 트리 탐색이라고 함

SELECT 뿐 아니라 UPDATE, DELETE 처리할 때도 사용

<br>

B-Tree 인덱스 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에도 사용

하지만 뒷부분만 검색하는 용도로는 X

또한 인덱스 키 값의 변형이 생긴 후 비교되는 경우에는 절대로 빠른 검색 기능을 사용할 수 없음

`따라서 함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 B-Tree의 장점을 이용할 수 없음`

<br>

InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현

따라서, UPDATE나 DELETE 문장이 실행될 때 적절히 사용할 수 있는 인덱스가 없으면 불필요한 레코드들을 잠금

그만큼 InnoDB에서는 인덱스의 설계가 중요하고 많은 부분에 영향을 미침

<br>

### B-Tree 인덱스 사용에 영향을 미치는 요소

B-Tree 인덱스는 인덱스를 구성하는 칼럼의 크기, 레코드의 건수, 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향을 받음

<br>

### 인덱스 키 값의 크기

`InnoDB에서 디스크에 데이터를 저장하는 가장 기본 단위는 페이지 or 블록`

디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위

페이지는 버퍼 풀에서 데이터를 버퍼링하는 기본 단위

인덱스도 페이지 단위로 관리되며, 루트, 브랜치, 리프 노드를 구분한 기준이 페이지 단위

<br>

B-Tree의 B는 Balanced

인덱스 페이지 크기와 키 값 크기에 따라 자식 노드의 갯수가 결정

<p align="center"><img src="./images/8_6.png" width="30%"></p>

<br>

해당 그림에서 하나의 인덱스 페이지(16KB)에 몇 개 키를 저장할 수 있을까?

키의 값이 16 바이트, 자식 노드 주소가 12 바이트

16 * 1024 / 16 + 12 ( 킬로바이트와 바이트의 단위 변환 때문에 1024를 곱함 ) 

총 585개 저장 가능

자식 노드를 585개 가질 수 있는 B-Tree


<br>

### B-Tree 깊이

인덱스 키 값이 커지면 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고

B-Tree 깊이가 깊어져서 디스크로부터 읽어야 하는 횟수가 늘어나고 느려진다는 것을 의미

<br>

### 선택도(기수성(Cardinality))

모든 인덱스 키 값 가운데 유니크한 값의 수를 의미

인덱스 키 값 가운데 중복된 값이 많아지면 기수성은 낮아지고, 선택도 또한 떨어짐

<br>

예를 들어, country 컬럼만 인덱스로 준비되어 있는 tb_city 테이블은 1만 건의 레코드가 있음

국가와 도시가 중복되어 저장되어 있지 않음

```
mysql > SELECT *
        FROM tb_test
        WHERE country = 'KOREA' AND city = 'SEOUL';
```

해당 쿼리를 실행했을 때,

country 컬럼의 유니크 값이 10개일 때와 1000개일 때를 비교해보자

- 10개일 때

    country = 'KOREA'라는 조건으로 인덱스를 검색하면 1000건이 일치하고 1000건 가운데 city = 'SEOUL' 인 레코드는 1건이므로 999건은 불필요하게 읽은 것 


- 1000개일 때

    country = 'KOREA'라는 조건으로 인덱스를 검색하면 10건이 일치하고 10건 가운데 city = 'SEOUL' 인 레코드는 1건이므로 9건은 불필요하게 읽은 것


이처럼 인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향

<br>

### 읽어야 하는 레코드의 건수

일반 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4 ~ 5배 비용이 더 많이 드는 작업으로 예측


즉, 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20 ~ 25%를 넘어서면 인덱스를 이용하지 않는 것이 효율적

<br>

### B-Tree 인덱스를 통한 데이터 읽기

MySQL이 인덱스를 이용하는 대표적인 방법 세가지

- 인덱스 레인지 스캔

- 인덱스 풀 스캔

- 루스 인덱스 스캔

### 인덱스 레인지 스캔

인덱스 레인지 스캔은 나머지 두 가지 접근 방식보다 빠른 방법

```
mysql > SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

<p align="center"><img src="./images/8_7.png" width="70%"></p>

<br>

인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식

루트 노드 -> 브랜치 노드 -> 리프 노드 까지 가야 필요한 레코드의 시작 지점을 찾을 수 있음

스캔하다가 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아서 다시 스캔

<p align="center"><img src="./images/8_8.png" width="70%"></p>

<br>

실제 데이터 파일의 레코드를 읽어오는 과정

루트와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고 그 지점부터 필요한 방향으로 인덱스를 읽어감

중요한 것은 어떤 방식으로 스캔하든 관계없이, 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져옴

별도의 정렬 과정이 수반되는 것이 아니라 인덱스 자체의 정렬 특성 때문에 자동임

<br>

인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요

리포 노드에 저장된 레코드 주소로 한 건 단위로 랜덤 I/O가 일어남

`그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업`

<br>

인덱스 레인지 스캔의 3가지 단계

1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾음 (인덱스 탐색)

2. 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 읽음 (인덱스 스캔)

3. 2번에서 읽은 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어옴

<br>

### 인덱스 풀 스캔

인덱스 풀 스캔은 인덱스의 처음부터 끝까지 모두 읽는 방식

쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식 사용

예를 들어 인덱스는 A, B, C 칼럼의 순서로 만들어져 있지만 쿼리의 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우

<br>

일반적으로 인덱스의 크기는 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다 인덱스만 읽는 것이 효율적

쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 사용

<p align="center"><img src="./images/8_9.png" width="60%"></p>

<br>

인덱스 리프 노드의 제일 앞 또는 뒤로 이동후 인덱스의 리프 노드를 연결하는 링크드 리스트를 따라서 처음부터 끝까지 스캔하는 방식

인덱스 레인지 스캔보다 빠르진 않지만 테이블 풀 스캔보다는 효율적

`하지만, 해당 방식으로 인덱스를 사용하는 경우는 인덱스를 효율적으로 사용하지 못하는 것`

<br>

### 루스 인덱스 스캔

듬성듬성하게 인덱스는 읽는 것, 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태

일반적으로 GROUP BY 또는 MAX, MIN 함수에 대해 최적화를 하는 경우

<p align="center"><img src="./images/8_10.png" width="60%"></p>

<br>

```
mysql > SELECT dept_no, MIN(emp_no)
        FROM dept_emp
        WHERE dep_no BETWEEN 'd002' AND 'd004'
        GROUP BY dept_no;
```

dept_emp 테이블은 dept_no와 emp_no 두 개의 컬럼으로 인덱스 생성

또한, (dept_no, emp_no) 조합으로 정렬까지 되어 있음

위의 그림과 같이 dept_no 그룹 별로 첫 번째 레코드의 emp_no만 읽으면 됨

즉, 인덱스에서 WEHRE 조건을 만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저는 알고 있기에 조건에 맞지 않으면 SKIP

<br>

### 인덱스 스킵 스캔

인덱스의 핵심은 값이 정렬되어 있다는 것, 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요

```
### 인덱스 생성
mysql > ALTER TABLE employees
        ADD INDEX ix_gender_birthdate (gender, birth_date);
```

```
### 인덱스를 사용하지 못하는 쿼리
mysql > SELECT * FROM employees WHERE birth_date>='1965-02-01';

### 인덱스를 사용할 수 있는 쿼리
mysql > SELECT * FROM employees WHERE gender = 'M' AND birth_date>='1965-02-01';
```

MySQL 8.0부터는 옵티마이저가 gender 칼럼을 건너뛰고 bith_date 칼럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입

<p align="center"><img src="./images/8_11.png" width="50%"></p>

<br>

gender 칼럼에 대해 가능한 값 2개를 구한 다음 birth_date를 찾는 방식으로 

<br>

인덱스 스킵 스캔의 단점

- WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함

- 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)


<br>

첫 번째 조건은 쿼리 실행 계획의 비용과 관련된 부분

유니크한 값의 개수가 매우 많다면 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해짐

그래서 인덱스의 선행 칼럼이 가진 유니크한 값의 개수가 소량일 때만 적용 가능한 최적화

<br>

### 다중 칼럼 인덱스

실제 서비스용 DB에서는 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용

<p align="center"><img src="./images/8_12.png" width="40%"></p>

<br>

해당 그림에서 인덱스의 두 번째 칼럼은 첫 번쨰 칼럼에 의존해서 정렬되어 있음

그렇기에 두 번째 칼럼의 정렬 순서가 앞에 있어도 첫 번째 칼럼의 정렬 순서가 뒤에 있으면 하단에 위치

`그래서 다중 칼럼 인덱스에서는 인덱스 내에서 각 칼럼의 순서가 상당히 중요`

<br>

### B-Tree 인덱스의 정렬 및 스캔 방향

인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 만든 실행 계획에 따라 결정

<br>

### 인덱스 스캔 방향

```
mysql > SELECT *
        FROM employees
        ORDER BY first_name DESC
        LIMIT 1;
```
해당 쿼리를 실행하기 위해 인덱스를 처음부터 오름차순으로 끝까지 읽어 마지막 값을 하나 가져올까?

답은 No

옵티마이저는 인덱스를 역순으로 접근해서 첫 번째 레코드만 읽음

<p align="center"><img src="./images/8_13.png" width="50%"></p>

<br>

즉, 인덱스 생성 시점에 오름차순, 내림차순으로 정렬이 결정되지만 사용하는 시점에서 방향을 다시 정함

<br>

### 내림차순 인덱스

2개 이상의 칼럼으로 구성된 복합 인덱스에서 내림차순과 오름차순이 혼합된 경우, 내림차순 인덱스로만 해결 가능

<p align="center"><img src="./images/8_14.png" width="60%"></p>

<br>

- 오름차순 인덱스

    작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스

- 내림차순 인덱스

    큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스

- 인덱스 정순 스캔

    인덱스 키의 크고 작음에 관계 없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔

- 오름차순 인덱스

    인덱스 키의 크고 작음에 관계 없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔

### 실습

<p align="center"><img src="./images/8_15.png" width="60%"></p>

<br>

<p align="center"><img src="./images/8_16.png" width="30%"></p>

<br>

약 2200만 개의 레코드가 들어 있는 테이블 생성


<p align="center"><img src="./images/8_17.png" width="90%"></p>

<br>

<p align="center"><img src="./images/8_18.png" width="50%"></p>

<br>

첫번째 쿼리

- t1 테이블에서 tid 컬럼을 기준으로 오름차순 정렬한 후, 22437887번째 행의 모든 열 값 1개를 반환

- 즉, 22437887번째 값

<br>

두번째 쿼리

- t1 테이블에서 tid 컬럼을 기준으로 내림차순 정렬한 후, 22437887번째 행의 모든 열 값 1개를 반환

- 즉, 첫번째 값

<br>

역순 정렬 쿼리가 정순 정렬 쿼리보다 약 3.7초 더 걸림

정순 스캔과 역순 스캔은 페이지(블록) 간의 Double linked list를 통해 Forward하느냐 Backward하느냐의 차이만 있지만 내부적으로는 차이가 나는 2가지 이유가 있음

1. 페이지 잠금이 인덱스 정순 스캔에 적합한 구조

2. 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

<p align="center"><img src="./images/8_19.png" width="50%"></p>

<br>

페이지 내부에서 레코드들이 정렬 순서대로 저장되어 있지 않고, 실제로는 Heap처럼 사용되기에 물리적으로 저장이 순서대로 배치되지는 않음

각 데이터 페이지나 인덱스 페이지의 엔트리(데이터 레코드 또는 인덱스 키)는 키 값과 데이터를 가지는데 

인덱스(프라이머리 키 인덱스와 세컨더리 인덱스 모두)의 루트 노드 또는 브랜치 노드라면 자식 노드의 주소를 가짐

프라이머리 키에서 리프 노드의 데이터는 실제 레코드의 칼럼 값들이며, 세컨더리 인덱스 페이지에서는 프라이머리 키 값을 가짐

<br>

### B-Tree 인덱스의 가용성과 효율성

쿼리의 WHERE 조건이나 GROUP BY, ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 함

그래야 쿼리 조건을 최적화하거나, 쿼리에 맞게 인덱스를 최적으로 생성

<br>

### 비교 조건의 종류와 효율성

다중 컬럼 인덱스에서 칼럼의 순서와 조건이 동등인지 >, < 같은 범위 조건인지에 따라 인덱스 칼럼의 활용 형태가 달라짐

```
mysql> SELECT * FROM dept_emp
        WHERE dept_no='d002' AND emp_no >= 10114;
```

이 쿼리를 위해 dept_emp 테이블에 각각 칼럼의 순서만 다른 두 가지 케이스로 인덱스를 생성

- 케이스 A: INDEX (dept_no, emp_no)
- 케이스 B: INDEX (emp_no, dept_no)

<br>

케이스 A

- dept_no='d002' AND emp_no>=10144 인 레코드를 찾고 dept_no='d002'가 아닐 때까지 인덱스를 쭉 읽기만 하면 됨

Why? 인덱스는 순서대로 정렬되어 있기 때문

<br>

케이스 B

-  emp_no>=10144 AND dept_no='d002' 인 레코드를 찾고 이후 모든 레코드에 대해 dept_no='d002'인지 비교해야 됨

<p align="center"><img src="./images/8_20.png" width="50%"></p>

<br>

`인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 필터링`

다중 칼럼 인덱스의 정렬 방식 때문에 A, B의 차이가 있는 것

케이스 A는 2번째 칼럼인 emp_no는 비교 작업의 범위를 좁히는 데 도움을 주지만

케이스 B는 dept_no의 비교 작업 단위를 좁히는데 도움을 주지 못했음

<br>

`작업의 범위를 결정하는 조건을 작업 범위 결정 조건`

`비교 작업의 범위를 줄이지 못하고 단순 거름종이 역할만 하는 조건을 필터링 조건`

<br>

### 인덱스의 가용성

B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬

그래서 LIKE '%mer' 같은 쿼리 처리를 인덱스로 할 수 없음

<br>

### 가용성과 효율성 판단

B-Tree 인덱스는 다음 조건(작업 범위 결정 조건)에서 사용 X

1. NOT-EQUAL로 비교된 경우(<>, NOT IN, NOT BETWEEN, IS NOT NULL)

    ```
    ### 예시

    WHERE column <> 'N'

    WHERE column NOT IN (10, 11, 12)

    WHERE column IS NOT NULL 
    ```

    이유
    
    `인덱스의 연속적인 범위를 활용할 수 없기에 인덱스 전체를 스캔하기 때문`

<br>

2. LIKE '%??' (앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우
   
    ```
    ### 예시

    WHERE column '%승환'

    WHERE column '_승환'

    ```

    이유

    `B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬`

<br>

3. 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
   
    ```
    ### 예시

    WHERE SUBSTRING(column, 1, 1) = 'X'

    WHERE DAYOFMONTH(column) = 1

    ```

    이유

    `인덱스 키 값이 변형되면 원래 인덱스의 정렬 순서가 무너짐`

<br>

4. NON-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우

    NON-DETERMINISTIC 속성을 가진 스토어드 함수는 `동일한 입력 값에 대해서도 호출될 때마다 다른 결과를 반환할 수 있는 함수`

    난수, 날짜, 시간 등
   
    ```
    ### 예시

    WHERE column = deterministic_function()
    ```

    이유

    `결과 값 예측 불가능`

<br>

5. 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
   
    ```
    ### 예시

    WHERE char_column = 10

    ```

    이유

    `숫자와 문자열의 정렬 순서가 다르고, 비교 의미가 모호하기에`

<br>

6. 문자열 데이터 타입의 콜레이션이 다른 경우
   
    ```
    ### 예시

    WHERE utf8_bin_char_column = euckr_bin_char_column

    ```

    이유

    `콜레이션은 문자열을 정렬하는 규칙인데 서로 다른 콜레이션을 사용하면 정렬 순서가 다름`

<br>

다중 컬럼 인덱스는 다음 조건(작업 범위 결정 조건)에서 사용 X

1. 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우

    ```
    ### 예시

    column_1 칼럼에 대한 조건이 없는 경우

    column_1 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우

    ```


<br>

2. 작업 범위 결정 조건으로 인덱스를 사용하는 경우
   
    ```
    ### 예시

    column_1 ~ column_(i-1) 칼럼까지 동등 비교 형태로 비교

    column_i 칼럼에 대해 다음 연산자 중 하나로 비교

    - 동등 비교

    - 크다 작다 형태

    - LIKE로 좌측 일치 패턴

    ```

<br>

위의 두가지 조건을 만족하는 쿼리는 column_1부터 column_i까지는 작업 범위 결정 조건으로 사용 가능

i+1 ~ n까지는 체크(필터링) 조건

<br>

예시

```
### 인덱스 사용 X
mysql> WHERE column_1 1 <> 2

### 1, 2 모두 범위 결정 조건으로 사용
mysql> WHERE column_1 = 1 AND column_2 > 10

### 1,2,3 모두 범위 결정 조건으로 사용
mysql> WHERE column_1 = 1 AND column_2 = 2 AND column_3 <= 10

### 1,2,3은 범위 결정 조건, 4는 체크 조건으로 사용
mysql> WHERE column_1 = 1 AND column_2 = 2 AND column_3 IN (10,20,30) AND column_4 <> 100

### 1,2,3,4 모두 범위 결정 조건으로 사용
mysql> WHERE column_1 = 1 AND column_2 IN (2,4) AND column_3 = 300 AND column_4 LIKE '김승%'

```

<br>

## R-Tree 인덱스

공간 인덱스는 R-Tree 인덱스 알고리즘을 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스

기본적인 내부 메커니즘은 B-Tree와 흡사

B-Tree는 인덱스를 구성하는 칼럼의 값이 1차원 스칼라 값이라면, R-Tree는 2차원 공간 개념 값

<br>

MySQL의 공간 확장의 3가지 기능

- 공간 데이터를 저장할 수 있는 데이터 타입

- 공간 데이터의 검색을 위한 공간 인덱스 (R-Tree 알고리즘)

- 공간 데이터의 연산 함수 (거리 또는 포함 관계의 처리)

<br>

### 구조 및 특성

MySQL은 공간 정보의 저장 및 검색을 위해 기하학적 도형 정보를 관리할 수 있는 데이터 타입을 제공

POINT, LINE, POLYGON, GEOMETRY

<br>

MBR이란 Minumum Bounding Rectangle의 약어

해당 도형을 감싸는 최소 크기의 사각형

이 사각형들의 포함 관계를 B-Tree 형태로 구현한 인덱스가 R-Tree 인덱스

<p align="center"><img src="./images/8_21.png" width="50%"></p>

<br>

최상위 레벨 : R1, R2

차상위 레벨 : R3, R4, R5, R6

최하위 레벨 : R7 ~ R14

<br>

최하위 레벨의 MBR은 각 도형 데이터의 MBR

차상위는 중간 크기 MBR(도형 객체 그룹)

최상위 MBR은 R-Tree 루트 노드에 저장

차상위는 브랜치 노드

최하위는 리프 노드

<p align="center"><img src="./images/8_22.png" width="70%"></p>

<br>

### R-Tree 인덱스의 용도

MBR 정보를 이용해 B-Tree 형태로 인덱스 구축을 하므로 Rectangle의 R 과 B-Tree의 Tree를 합쳐 R-Tree라는 이름이 붙여짐

일반적으로 `GPS 기준의 위도 경도 좌표 저장에 주로 사용`

CAD/CAM 소프트웨어 또는 회로 디자인 등 좌표 시스템에 기반을 둔 정보에 대해서 모두 적용 가능

<br>

현재 사용자 위치로부터 반경 5km 이내의 음식점 검색 같은 검색에 사용 가능

<br>

현재 MySQL에서 거리를 비교하는 ST_Distance(), ST_Distance_Sphere() 함수는 

공간 인덱스를 효율적으로 사용하지 못하기 때문에 

ST_Contains(), ST_Within()을 이용해 거리 기반의 검색을 해야 함

<br>

<p align="center"><img src="./images/8_23.png" width="40%"></p>

<br>

해당 그림에서 P는 기준점이며, 기준점으로부터 5km 이내의 점들을 검색하려면

ST_Contains(), ST_Within()을 이용해 점들을 검색

But ST_Contains(), ST_Within()는 사각형과 같은 다각형으로만 연산이 가능하므로 5km 원을 포함하는 최소 삼각형(MBR)으로 포함 관계 비교를 수행

<br>

```
### ST_Contains(), ST_Within()을 이용해 사각 상자에 포함된 좌표 Px만 검색

mysql> SELECT * FROM tb_location
        WHERE ST_Contains(사각상자, px);

mysql> SELECT * FROM tb_location
        WHERE ST_Within(px, 사각상자);

```


<br>

그래서 점 P6는 5km 이상 떨어져 있지만 MBR에는 포함되어 있음

P6를 빼고 결과를 조회하려면 ST_Contains() 비교 결과에 대해 ST_Distance_Sphere() 함수를 이용해 다시 한번 필터링해야 함

```
mysql> SELECT * FROM tb_location
        WHERE ST_Contains(사각상자, px) // 공간 좌표 Px 가 사각 상자에 포함되는지 비교
        AND ST_Distance_Sphere(p, px)<=5*1000 // 5km

### 즉, MBR에 포함되어 있으면서 기준점 p와 반경 5km 안에 있는지 체크
```

<br>

## 전문 검색 인덱스

지금까지 살펴본 인덱스 알고리즘은 크지 않은 데이터, 이미 키워드화한 작은 값에 대한 인덱싱 알고리즘

B-Tree 인덱스는 실제 칼럼의 값이 1MB라도 3072바이트(InnoDB)까지만 잘라서 인덱스 키로 사용

또한 전체 일치 또는 좌측 일부 일치 같은 검색만 가능

<br>

문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문 검색에는 B-Tree 인덱스를 사용할 수 없음

<br>

### 인덱스 알고리즘

전문 검색 인덱스는 문서의 키워드를 인덱싱하는 기법에 따라 2가지로 구분

- 어근 분석

- n-gram 분석

<br>

### 어근 분석 알고리즘

불용어 처리와 어근 분석을 통해 색인 작업이 수행

불용어 처리란 별 가치가 없는 단어를 필터링해서 제거하는 작업

어근 분석은 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업

<br>

Mecab(형태소 분석 프로그램)을 이용해 한글 분석

<br>

### n-gram 알고리즘

Mecab은 전문적인 검색 엔진을 고려하는 것이 아니라면 적용하기 쉽지 않음

이런 단점을 보완하기 위해 n-gram이 도입

n-gram이란 단순 키워드 검색 인덱싱 알고리즘이며, 본문을 무조건 몇 글자씩 잘라서 인덱싱하는 방식

n은 인덱싱할 키워드의 최소 글자 수인데 보통 2글자 단위로 사용

<br>

```
### 예시

To be or not to be. That is the question
```

<p align="center"><img src="./images/8_24.png" width="40%"></p>

<br>

토큰들을 추출해서 불용어 필터링을 함

<p align="center"><img src="./images/8_25.png" width="40%"></p>

<br>

출력에 해당하는 것들을 전문 검색 인덱스에 등록

### 불용어 변경 및 삭제

불용어에는 사용자에 도움이 되기보다 혼란스럽게 하는 경우도 있기에 무시하거나 직접 불용어 등록을 하는 것을 권장

<br>

### 전문 검색 인덱스의 가용성

전문 검색 인덱스를 사용하려면 두 가지 조건을 갖춰야 함

- 쿼리 문장이 전문 검색을 위한 문법(MATCH ... AGAINST ...)을 사용

- 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유

<br>

```
### doc_body 칼럼에 전문 검색 인덱스 생성

mysql> CREATE TABLE tb_test (
        doc_id INT,
        doc_body TEXT,
        PRIMARY KEY (doc_id),
        FULLTEXT KEY fx_docbody (doc_body) WITH PARSER ngram
) ENGINE=innoDB;

```
<br>

```
### 비효율적으로 쿼리 실행하는 케이스

mysql> SELECT * FROM tb_test WHERE doc_body LIKE '%애플%';
```

```
### 인덱스를 사용해 쿼리 실행하는 케이스
### MATCH, AGAINST 구문으로 작성해야 하며 MATCH 절 괄호에 전문 검색 인덱스 칼럼을 명시
mysql> SELECT * FROM tb_test 
        WHERE MATH(doc_body) AGAINST('애플', IN BOOLEAN MODE);
```

<br>

## 함수 기반 인덱스

일반적인 인덱스는 칼럼의 값 일부(칼럼의 값 앞부분) 또는 전체에 대해서만 인덱스 생성 허용

하지만 칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축해야 할 때가 있는데, 이럴 때 함수 기반 인덱스를 활용

<br>

- 가상 컬럼을 이용한 인덱스

- 함수를 이용한 인덱스

<br>

함수 기반 인덱스는 실제 인덱스의 내부적인 구조 및 유지관리 방법은 B-Tree 인덱스와 동일

<br>

### 가상 칼럼을 이용한 인덱스

```
### 사용자 정보 저장 테이블

mysql> CREATE TABLE user (
        user_id BIGINT,
        first_name VARCHAR(10),
        last_name VARCHAR(10),
        PRIMARY KEY (user_id)
);
```

first_name과 last_name을 합쳐서 검색해야 하는 요건이 생겼다면 가상 칼럼을 추가하고 거기에 인덱스 생성이 가능

```
mysql> ALTER TABLE user 
        ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,
        ADD INDEX ix_fullname (full_name);
```

<br>

### 함수를 이용한 인덱스

```
mysql> CREATE TABLE user (
        user_id BIGINT,
        first_name VARCHAR(10),
        last_name VARCHAR(10),
        PRIMARY KEY (user_id),
        INDEX ix_fullname((CONCAT(first_name, ' ', last_name)));
);
```

```
### 이와 같이 WHERE 절에 정확하게 맞는 표현식을 사용해서 사용

mysql> SELECT * FROM user WHERE CONCAT(first_name, ' ', last_name)='Matt Lee';
```

<br>

## 멀티 밸류 인덱스

전문 검색 인덱스를 제외한 모든 인덱스는 레코드 1건이 1개의 인덱스 키 값을 가짐

즉, 인덱스 키와 데이터 레코드는 1:1 관계

<br>

멀티 밸류 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스

이러한 인덱스는 정규화에 위배되는 형태

하지만 최근 RDBMS들이 json 데이터 타입을 지원하기 시작하면서 해당 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생

<br>

MongoDB는 처음부터 이런 형태를 지원하고 있었지만 MySQL은 8.0부터 지원

```
### 신용 정보 점수를 배열로 JSON 타입 칼럼에 저장하는 테이블

mysql> CREATE TABLE user (
        user_id BIGINT AUTO_INCREMENT PRIMARY KEY,
        first_name VARCHAR(10),
        last_name VARCHAR(10),
        credit_info JSON,
        INDEX mx_creditscores( (CAST(credit_info->'$.credit_scores' AS UNSIGNED ARRAY)) )
);

### 값 삽입

mysql> INSERT INTO user VALUES (1, 'Matt', 'Lee', '{"credit_scores":[360, 353, 351]}');
```

<br>

멀티 밸류 인덱스를 활용하기 위해서는 반드시 다음 함수들을 사용

- MEMBER OF()

- JSON_CONTAINS()

- JSON_OVERLAPS()

```

mysql> SELECT * FROM user WHERE 360 MEMBER OF(credit_info->'$.credit_scores');
```

<p align="center"><img src="./images/8_26.png" width="40%"></p>

<br>

## 클러스터링 인덱스

클러스터링이란 여러 개를 하나로 묶는다는 의미

MySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(PK 키를 기준으로)들끼리 묶어서 저장하는 형태

이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안

<br>

### 클러스터링 인덱스

클러스터링 인덱스는 테이블의 PK 키에만 적용이되는 내용

즉, PK 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현

`PK 값에 의해 레코드의 저장 위치가 결정되는 것이기에 PK 키 값이 변경된다면 물리적인 저장 위치가 바뀌어야 한다는 것을 의미`

PK 값으로 클러스터링된 테이블은 PK 값 자체에 대한 의존도가 상당히 크기 때문에 신중하게 PK 키를 결정

<br>

`클러스터링 인덱스는 PK 값에 의해 레코드의 저장 위치가 정해지므로 사실 인덱스 알고리즘이라기보다 테이블 레코드 저장 방식이라고 볼 수 있음`

그래서 클러스터링 인덱스 == 클러스터링 테이블

<br>

B-Tree 인덱스도 인덱스 키 값으로 이미 정렬되어 저장되지만, PK 값으로 정렬이 된 것이 아니기에 레코드가 PK 값으로 정렬되어 저장된 경우만 클러스터링 인덱스

<br>

### 클러스터링 테이블 구조


<p align="center"><img src="./images/8_27.png" width="60%"></p>

<br>

B-Tree와 유사하지만 리프 노드에 레코드의 모든 칼럼이 같이 저장되어 있음

<br>

```
### PK 키를 변경하는 쿼리가 실행되면 어떤 변화가?

mysql> UPDATE tb_test SET emp_no=100002 WHERE emp_no=100007; 
```


<p align="center"><img src="./images/8_28.png" width="60%"></p>

<br>

페이지 3에서 페이지 2로 이동

실제로 PK 값이 변경되는 경우는 거의 없지만 클러스터링 테이블의 작동 방식을 알아보기 위해

<br>

### 그렇다면 PK 키가 없는 InnoDB 테이블은 어떻게 클러스터링 테이블로 구성될까??

PK 키가 없는 경우 해당 순서대로 PK 키를 대체할 칼럼을 선택

1. PK 키가 있으면 PK 키를 선택

2. NOT NULL 옵션의 유니크 인덱스 중에 첫 번째 인덱스를 선택

3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후 선택

<br>

이처럼 적절한 클러스터링 키 후보를 찾지 못하는 경우 InnoDB 엔진이 내부적으로 레코드의 일련번호 칼럼을 생성

이 컬럼은 사용자에게 노출되지 않으며, 쿼리 문장에 명시적 사용 불가

그래서 가능하다면 PK 키를 명시적으로 생성해서 클러스터링 인덱스의 혜택을 누리자

<br>

### 세컨더리 인덱스에 미치는 영향

MyISAM이나 MEMORY 테이블 같이 클러스터링되지 않은 테이블은 INSERT 될 때 처음 저장된 공간에서 절대 이동하지 않음

그래서 레코드 아이디(ROWID)를 이용해 실제 데이터 레코드를 찾아옴

<br>

그렇다면 InnoDB 세컨더리 인덱스가 실제 레코드가 저장된 주소를 갖고 있다면?

클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고 모든 인덱스에 저장된 주소 값을 변경해야 할 것

이런 오버헤드를 제거하기 위해 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 PK 키 값을 저장하도록 구현

<br>

```
mysql> CREATE TABLE employees (
        emp_no INT NOT NULL,
        first_name VARCHAR(20) NOT NULL,
        PRIMARY KEY (emp_no),
        INDEX ix_firstname  (first_name)
);

mysql> SELECT * FROM employees WHERE first_name='Aamer'; 
```

- MyISAM

    ix_firstname 인덱스를 검색해서 레코드의 주소를 확인한 후, 레코드의 주소를 이용해 최종 레코드를 가져옴


- InnoDB

    ix_firstname 인덱스를 검색해 레코드의 프라이머리 키 값을 확인한 후, 프라이머리 키 인덱스를 검색해서 최종 레코드를 가져옴

<br>

```
## innodb의 세컨더리 인덱스가 pk 키를 가지고 있다는 것

InnoDB 스토리지 엔진에서 세컨더리 인덱스가 PK(기본 키)를 포함한다는 것은 인덱스에 실제 데이터 값 뿐만 아니라 해당 레코드의 PK 값도 함께 저장된다는 뜻입니다. 

이를 통해 세컨더리 인덱스를 통해 레코드를 찾은 후 실제 데이터를 가져오는 과정에서 추가적인 조인 없이 바로 데이터에 접근할 수 있습니다.

PK를 포함하지 않는 세컨더리 인덱스라면, 인덱스를 통해 레코드를 찾은 후에 실제 데이터를 가져오기 위해 별도의 조인 작업이 필요합니다. 이는 성능 저하를 초래할 수 있습니다.

따라서 InnoDB의 세컨더리 인덱스에 PK를 포함시키는 것은 인덱스 액세스 후 실제 데이터에 빠르게 접근할 수 있게 해주어 전체적인 쿼리 성능을 향상시킵니다.

```


### 클러스터링 인덱스의 장점과 단점

장점

- PK 키로 검색할 때 처리 성능이 매우 빠름. 특히, PK 키를 범위 검색하는 경우 매우 빠름

- 테이블의 모든 세컨더리 인덱스가 PK 키를 가지고 있기에 인덱스만으로 처리될 수 있는 경우가 많음 (커버링 인덱스)

<br>

단점

- 모든 세컨더리 인덱스가 PK 키를 갖기 때문에 PK 키 값의 크기가 클 경우 전체적으로 인덱스 키가 커짐

- 세컨더리 인덱스를 통해 검색할 때 PK 키로 다시 한번 검색해야 하므로 처리 성능이 느림

- INSERT할 때 PK 키에 의해 레코드 저장 위치가 결정되기에 처리 성능이 느림

- PK 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기에 처리 성능이 느림

<br>

`클러스터링 인덱스의 장점은 빠른 읽기(SELECT), 단점은 느린 쓰기(INSERT, UPDATE, DELETE)`

일반적으로 웹 서비스와 같은 OLTP에서는 쓰기 읽기 비율이 2:8, 1:9이기에 읽기를 빠르게 유지하는 것이 매우 중요

<br>

### 클러스터링 테이블 사용 시 유의 사항

### 클러스터링 인덱스 키의 크기

세컨더리 인덱스에 PK 값을 포함하기에 PK 키는 신중하게 선택

<br>

### 프라이머리 키는 AUTO_INCREMENT보다 업무적인 칼럼으로 생성(가능한 경우)

`PK 키에 의해 레코드의 위치가 정해지기에 업무적으로 해당 레코드를 대표할 수 있는 것을 설정하는 것이 검색할 때 매우 빠르게 처리될 수 있음`

<br>

### 프라이머리 키는 반드시 명시할 것

가능한 AUTO_INCREMENT 칼럼을 이용해서라도 PK 키는 생성하자

내부적으로 생성된 일련번호 칼럼은 사용자가 접근할 수 없음

ROW 기반의 복제나 InnoDB Cluster에서는 모든 테이블이 PK 키를 가져야만 정상 복제 성능을 보장하기에 PK 키는 꼭 생성하자

<br>

### AUTO_INCREMENT 칼럼을 인조 식별자로 사용할 경우

여러 개의 칼럼이 복합으로 PK 키가 만들어지는 경우 PK 키의 크기가 길어질 때가 가끔 있음

하지만, PK 키의 크기가 길어도 세컨더리 인덱스가 필요치 않으면 그대로 프라이머리 키를 사용하는 것이 좋음

세컨더리 인덱스도 필요하고, PK 키의 크기도 길다면 AUTO_INCREMENT를 사용하여 PK 키로 설정하자

<br>

## 유니크 인덱스

유니크는 인덱스라기보다 제약 조건에 가까움

MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없음

PK 키는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동 부여

<br>

### 유니크 인덱스와 일반 세컨더리 인덱스의 비교

### 인덱스 읽기

유니크 인덱스가 빠르다고 생각하지만 아님

유니크하지 않은 세컨더리 인덱스에서 더 하는 작업은 CPU에서 칼럼 값을 비교하는 작업이기에 이는 성능상 영향이 거의 없음

유니크하지 않은 세컨더리 인덱스는 중복 값을 허용하므로 읽어야 할 레코드가 많아 느린 것이지 인덱스 자체의 특성 때문에 느린 것이 아님

즉, 레코드 1건을 읽을 때 0.1초, 레코드 2건을 읽을 때 0.2초가 걸렸을 때 후자를 느리다고 할 수 없는 것과 같은 이치

<br>

### 인덱스 쓰기

새로운 레코드가 INSERT되거나 인덱스 칼럼의 값이 변경되는 경우 인덱스 쓰기 작업이 필요

그런데 유니크 인덱스 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 더 필요

그래서 유니크하지 않은 세컨더리 인덱스보다 쓰기가 느림

<br>

MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기 할 때는 쓰기 잠금을 사용하는데 이 과정에서 데드락이 빈번히 발생

체인지 버퍼 사용 또한 유니크 인덱스는 반드시 중복 체크를 해야하므로 작업을 버퍼링하지 못함

이 때문에 유니크 인덱스는 일반 세컨더리 인덱스보다 변경 작업이 더 느림

<br>

### 유니크 인덱스 사용시 주의 사항

성능 향상을 기대한 유니크 인덱스 생성은 X

MySQL의 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하므로 중복 인덱스 생성 X

즉, nick_name 칼럼에 대해서 유니크 인덱스와 일반 인덱스를 둘 다 생성하지 말자

결론적으로 유일성이 꼭 보장되어야 하는 칼럼에 대해서만 유니크 인덱스를 생성하자

<br>

## 외래키

외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성

외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없음

<br>

InnoDB 외래키 관리의 두 가지 특징

- 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 대기가 발생

- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 대기를 발생 X

DB에서 외래 키를 물리적으로 생성하려면 잠금 경합(대기)까지 고려해서 모델링을 진행하는 것이 좋음

물리적인 외래키의 고려 사항은 연관 테이블의 읽기 잠금을 걸어야 한다는 것이기에 쿼리의 동시 처리에 영향을 미침