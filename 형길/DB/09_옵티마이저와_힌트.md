# 9장. 옵티마이저와 힌트

MySQL 서버로 요청된 쿼리는 어떤 방법이 최적이고 최소의 비용이 소모될지 결정해야 함

쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장되어 있는지 통계 정보를 참조하고, 그런 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요

DBMS에서는 옵티마이저가 이러한 기능을 담당

<br>

EXPLAIN 명령어로 쿼리의 실행 계획을 확인 가능한데, 해당 내용을 이해하기 위해서는 옵티마이저가 실행하는 최적화에 대해 어느 정도 알아야 함

<br>

## 개요

어떤 DBMS든지 옵티마이저 + 실행 계획 이해가 가장 복잡한 부분

하지만 실행 계획을 이해해야지만 실행 계획의 불합리한 부분을 찾아내고 더 최적화된 실행 계획을 수립할 수 있도록 유도 가능

<br>

### 쿼리 실행 절차

쿼리 실행 과정

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리

2. SQL의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택

3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴

<br>

첫 번째 단계를 SQL 파싱이라고 하며 SQL 파서라는 모듈로 처리

SQL 문장이 문법적으로 잘못됐다면 이 단계에서 걸러짐

또한 이 단계에서 SQL 파스 트리가 생성

MySQL 서버는 SQL 파스 트리를 이용해 쿼리를 실행

<br>

두 번째 단계는 SQL 파스 트리를 참조하면서 다음을 처리

- 불필요한 조건 제거 및 복잡한 연산 단순화

- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정

- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정

- 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

`이처럼 두 번째 단계는 최적화 및 실행 계획 수립 단계이며, 완료되면 실행 계획이 만들어짐`

<br>

세 번쨰 단계는 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고, MySQL 엔진에서는 받은 레코드를 조인하거나 정렬하는 작업을 수행

<br>

### 옵티마이저의 종류

비용 기반 최적화 VS 규칙 기반 최적화

<br>

- 규칙 기반 최적화

    대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식

    통계 정보(테이블의 레코드 건수나 칼럼값의 분포도)를 조사하지 않고 수립하기에 같은 쿼리에 대해서는 같은 실행 방법을 만듦

    요즘 사용 X

<br>

- 비용 기반 최적화

    쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용 산출

    이 중 최소로 소요되는 처리 방식을 선택해 쿼리 실행

<br>

## 기본 데이터 처리

모든 RDBMS는 데이터를 정렬하거나 그루핑 하는 등의 기본 데이터 가공 기능을 가지고 있음

MySQL 서버가 어떤 알고리즘을 사용하는지 알아보자

<br>

### 풀 테이블 스캔과 풀 인덱스 스캔

`풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리`

다음과 같은 조건일 때 `풀 테이블 스캔을 선택`

1. 테이블의 `레코드 건수가 작아서` 인덱스를 통해 읽는 것보다 풀 테이블 스캔이 더 빠른 경우

    (일반적으로 테이블이 페이지 1개로 구성된 경우)

<br>

2. WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 `적절한 조건이 없는` 경우

<br>

3. 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 `레코드 건수가 너무 많은` 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

<br>

일반적으로 테이블 전체 크기는 인덱스보다 크기에 테이블 풀 스캔은 많은 디스크 읽기가 필요

그래서 풀 테이블 스캔을 실행할 때 한 번에 여러 개의 블록(페이지)를 읽어오는 기능이 내장

하지만 `MySQL에서는 풀 테이블 스캔을 실행할 때 몇 개씩 블록을 읽어올지 설정하는 시스템 변수는 X`

<br>

InnoDB는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동으로 시작

`리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것`

<br>

풀 테이블 스캔 실행 과정

1. 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 싫애

2. 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘김

3. 이후부터 한 번에 4개 또는 8개씩 페이지를 읽으면서 계속 그 수를 증가시킴

4. 최대 64개 데이터 페이지까지 읽어서 버퍼 풀에 저장

5. 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용

<br>

innodb_read_ahead_threshold 시스템 변수를 통해 언제 리드 어헤드를 시작할지 임계값 설정 가능

DW 용으로 MySQL을 사용한다면 이 옵션을 디폴트보다 낮춰 빨리 리드 어헤드를 시작되게 유도하는 것도 좋은 방법

<br>

리드 어헤드는 풀 인덱스 스캔에서도 동일하게 사용

```
mysql> SELECT COUNT(*) FROM employees;
```

해당 쿼리는 풀 테이블 스캔을 할 것처럼 보이지만 사실은 풀 인덱스 스캔을 할 가능성이 높음

단순 레코드 건수를 필요로 하는 쿼리는 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 횟수를 줄일 수 있기에

Why?

`인덱스는 테이블의 2 ~ 3개의 칼럼만으로 구성되기 때문에 테이블 자체보다 용량이 작아서 빠르게 처리 가능`

```
mysql> SELECT * FROM employees;
```

해당 쿼리처럼 레코드에만 있는 칼럼이 필요한 경우에는 풀 테이블 스캔

<br>

### 병렬 처리

8.0 버전부터 처음으로 쿼리의 병렬 처리가 가능(용도 한정)

`병렬 처리란 하나의 쿼리를 여러 스레드가 작업을 나누어서 동시에 처리하는 것`

그 전까지는 여러 스레드가 동시에 각각의 쿼리를 처리했었음

<br>

innodb_parallel_read_threads라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지를 변경

아직 병렬로 처리하게 하는 힌트나 옵션은 없음

해당 예제 같이 `아무런 WHERE 조건 없이 단순 테이블의 전체 건수를 가져오는 쿼리만 병렬 처리 가능`

<p align="center"><img src="./images/9_1.png" width="60%"></p>

<br>

병렬 처리용 스레드 개수가 늘어날수록 쿼리 처리에 걸리는 시간이 줄어드는 것을 확인 가능

하지만 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수도 있으니 주의

<br>

### ORDER BY 처리 (Using filesort)

대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용

DW처럼 대량의 데이터를 조회해서 일괄 처리하는 기능이 아니라면 `레코드 정렬 요건은 대부분 조회 쿼리에 포함돼 있을 것`

정렬을 처리하는 방법

- 인덱스 이용

- 쿼리 실행시 `Filesort` 라는 별도 처리

||장점|단점|
|------|---:|---:|
|인덱스 이용|INSERT, UPDATE, DELETE 쿼리가 실행될 때 <br> 이미 인덱스가 정렬돼 있어서 <br> 순서대로 읽기만 하면 되어 매우 빠름|INSERT, UPDATE, DELETE 작업시 <br> 부가적인 인덱스 추가/삭제 <br> 작업이 필요하므로 느림 <br> <br> 인덱스 때문에 디스크 공간이 더 필요 <br> <br> 인덱스의 개수가 늘어날수록 <br>  InnoDB의 버퍼 풀을 <br> 위한 메모리가 많이 필요 |
|Filesort 이용|인덱스를 생성하지 않아도 되므로 <br> 인덱스 이용 단점이 장점 <br> 정렬해야할 레코드가 많지 않으면 <br> 메모리에서 Filesort가 처리되므로 충분히 빠름|정렬 작업이 쿼리 실행시 처리되므로 <br> 레코드 대상 건수가 많아질수록 <br> 쿼리 응답 속도 하락|

<br>

모든 정렬을 인덱스를 이용하도록 튜닝하기 어려운 이유

- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우

- GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우

- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우

- 랜덤하게 결과 레코드를 가져와야 하는 경우

실행 계획의 Extra 칼럼에 Using filesort 메세지가 표시

<br>

MySQL 정렬 특성을 이해해보자

### 소트 버퍼

