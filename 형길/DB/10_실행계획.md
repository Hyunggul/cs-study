# 10장. 실행계획

DBMS는 `많은 데이터를 안전하게 저장 및 관리하고 사용자가 원하는 데이터를 빠르게 조회`할 수 있게 해주는 것이 주목적

옵티마이저가 최적으로 처리될 수 있게 하는 쿼리의 실행 계획 수립 중요

But, 옵티마이저가 개입 없이 항상 좋은 실행 계획을 만들어낼 수 있는 것은 X

EXPLAIN 명령으로 실행 계획 확인

<br>

MySQL 서버가 데이터를 처리하는 로직을 이해할 필요

해당 장에서는 통계 정보, 실행 계획 읽는 순서, 출력 키워드, 알고리즘에 대해서 공부

<br>

## 통계 정보

5.7 버전까지는 테이블 칼럼의 값들이 실제 어떻게 분포돼 있는지에 대한 정보가 없어 실행 계획의 정확도가 떨어지는 경우가 다수

8.0 버전 부터는 인덱스되지 않은 칼럼에 대해서도 데이터 분포도의 히스토그램 정보가 도입

<br>

### 테이블 및 인덱스 통계 정보

```
RBO의 경우 예측이 가능하며, 안정적이고 플랜의 제어가 쉬움 
이런 이유 때문에 일부 DBA나 고급 개발자들은 이 방식을 선호

CBO의 경우 예측 불가능하고 플랜의 제어가 쉽지 않음
간혹 잘못된 실행 계획을 제공하는 경우도 존재

첫째, 최적의 인덱스 구성하기
둘째, 올바른 SQL문 작성하기
셋째, 주기적이거나 혹은 최신의 통계정보 갱신하기
넷째, 힌트절 추가해 옵티마이저 제어하기
```

CBO에서 가장 중요한 것은 통계 정보

정확하지 않다면 전혀 엉뚱한 방향으로 쿼리를 실행하기 때문

MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 실제 테이블의 데이터를 일부 분석해서 통계 정보를 보완해서 사용

<p align="center"><img src="./images/10_3.png" width="50%"></p>

MySQL DB에 존재하는 innodb_index_stats, innodb_table_stats에서 통계 정보를 확인 및 관리 가능

<p align="center"><img src="./images/10_1.png" width="60%"></p>

stat_value = 지정된 통계량 값
sample_size = 제공된 견적에 대해 샘플링된 페이지 수

<p align="center"><img src="./images/10_2.png" width="100%"></p>

이렇게 테이블로 관리함으로써 MySQL 서버가 재시작돼도 기존의 통계 정보를 유지할 수 있음

<br>

테이블을 생성할 때는 stats_persistent 옵션을 설정할 수 있는데 이 설정 값에 따라 테이블 단위로 영구적인 통계 정보를 보관 결정

<p align="center"><img src="./images/10_4.png" width="70%"></p>

stats_persistent 옵션의 기본값은 ON(1)

<p align="center"><img src="./images/10_5.png" width="100%"></p>

- inndb_index_stats.stat_name='n_diff_pfx%'

    인덱스가 가진 유니크한 값의 개수

- inndb_index_stats.stat_name='n_leaf_pages'

    인덱스의 리프 노드 페이지 개수

- inndb_index_stats.stat_name='size'

    인덱스 트리의 전체 페이지 개수

- innodb_table_stats.n_rows

    테이블의 전체 레코드 건수

- innodb_table_stats.clustered_index_size

    프라이머리 키의 크기(innodb 페이지 개수)

- innodb_table_stats.sum_of_other_index_sizes

    프라이머리 키를 제외한 인덱스의 크기(innodb 페이지 개수)


<br>

#### 질문

innodb_index_stats 테이블을 열어봤을 때, gender로 설명되는 인덱스의 유니크한 값의 개수가 1개로 나와 있는데 실제 테이블을 열어봤을 때 M, F 두 가지의 유니크한 값이 나와 있음 Why?

<p align="center"><img src="./images/10_6.png" width="100%"></p>

-> Uzi의 답변

    table status로 employees 테이블을 확인해본 결과 Rows는 299113이었지만 실제 count를 해봤을 때 300024로 숫자가 달랐음

    이것은 통계 정보의 오류로, 통계 정보는 틀릴 수 있는 가능성을 항상 가지고 있으며 이것이 CBO의 단점

<p align="center"><img src="./images/10_7.png" width="100%"></p>


<br>

통계 정보는 해당 이벤트로 자동 갱신

- 테이블이 새로 오픈되는 경우

- 테이블의 레코드가 대량으로 변경되는 경우(테이블의 전체 레코드 중에서 1/16 정도의 UPDATE 또는 INSERT나 DELETE가 실행되는 경우)

- ANALYZE TABLE 명령이 실행되는 경우

- SHOW TABLE STATUS 명령이나 SHOW INDEX FROM 명령이 실행되는 경우

- InnoDB 모니터가 활성화되는 겨웅

- innodb_stats_on_metadata 시스템 설정이 ON인 상태에서 SHOW TABLE STATUS 명령이 실행되는 경우

이렇게 자주 통계 정보가 갱신되면 인덱스 레인지 스캔으로 잘 처리하다가도 갑자기 풀 테이블 스캔이 실행되는 상황이 생길수도

innodb_stats_auto_recalc 시스템 변수를 OFF로 설정하면 자동 갱신을 막을 수 있음

Default 값은 1

0으로 설정시 ANALYZE TABLE 명령으로 실행할 때만 갱신

<br>

- innodb_stats_transient_sample_pages

    기본값은 8로, 자동으로 통계 정보 수집이 실행될 떄 8개의 페이지만 임의로 샘플링해서 분석하고 그 결과를 통계 정보로 활용

    해당 변수를 높게 설정시 더 정확한 통계 정보를 수집할 수 있음
    
    너무 높이면 시간이 길어짐

- innodb_stats_persistent_sample_pages

    기본값은 20이며, ANALYZE TABLE 명령이 실행되면 임의로 20개 페이지만 샘플링해서 분석하고 그 결과를 영구적인 통계 정보 테이블에 저장하고 활용

<br>

### 히스토그램

8.0 버전부터 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용

<br>

### 히스토그램 정보 수집 및 삭제

히스토그램 정보는 칼럼 단위로 관리되는데 자동 수집으로는 안되고

ANALYZE TABLE ... UPDATE HSTOGRAM 명령으로 수동으로 수집 및 관리

<br>

수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고

MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 information_schema db의 column_statistics 테이블로 로드

그래서 실제 히스토그램 정보를 조회하려면 column_statistics 테이블을 SELECT해서 참조

<br>

### 실습

<p align="center"><img src="./images/10_8.png" width="100%"></p>

```
### 참고

enum type

데이터 중에는 몇 가지의 한정된 값만 갖는 경우

예를 들어 행정구역, 계절, 성별 ...

성질이 비슷한 상수를 모아놓음
```

2종류의 히스토그램 타입 지원

- Singleton 히스토그램

    칼럼값 개별로 레코드 건수를 관리하는 히스토그램

    = 도수 분포

- Equi-Height 히스토그램

    칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램

    = Height-Balanced 히스토그램

히스토그램은 Bucket 단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리

싱글톤 히스토그램은 칼럼이 가지는 값별로 버킷이 할당

```
"buckets": [[1, 0.6008588895063911], [2, 1.0]]

이렇게 2개 할당

칼럼의 값과 발생 빈도 비율 2가지의 값
```

높이 균형 히스토그램은 개수가 균등한 칼럼값 범위별로 하나의 버킷이 할당

```
"buckets": [["1985-02-01", "1985-03-01", 0.010023745768706108, 29], ["1985-03-02", "1985-03-29", 0.019966654877987166, 28], ["1985-03-30", "1985-04-26", 0.02997019148183701, 28], ["1985-04-27", "1985-05-23", 0.03989289142626181, 27], ...]

이렇게 균등한 개수를 정하고 칼럼값 범위를 나눠서 할당
## 29, 28.. 는 각 버킷에 포함된 유니크한 값의 개수니까 다른 거임

범위 시작 값, 마지막 값, 발생 빈도율, 버킷에 포함된 유니크한 값의 개수 등 4개의 값
```

히스토그램의 모든 레코드 건수 비율은 누적으로 표시

예를 들어, gender에서 비율이 1이 0.6 2가 1 인데 이것은 2 값이 1 - 0.6인 0.4라는 뜻

높이 균형 히스토그램의 누적 비율이 일정한 것을 보면 각 범위가 비슷한 레코드의 건수를 가진다는 것을 알 수 있음

<br>

나머지 필드의 값

- sampling-rate

    히스토그램 정보를 수집하기 위해 스캔한 페이지의 비율

    histogram_generation_max_mem_size 시스템 변수에 설정된 메모리 크기에 맞게 적절히 샘플링

    default는 20MB

- histogram-type

    히스토그램 종류 저장

- number-of-buckets-specified

    히스토그램을 생성할 때 설정했던 버킷의 개수 저장

    기본으로 100개, 최대 1024개 설정 가능

<br>

생성된 히스토그램 삭제

<p align="center"><img src="./images/10_9.png" width="100%"></p>

<br>

히스토그램을 사용하지 않으려면

```
mysql> SET GLOBAL optimizer_switch='condition_fanout_filter=off'

// 현재 커넥션에서 실행되는 쿼리만 히스토그램을 사용하지 않게 설정
mysql> SET SESSION optimizer_switch='condition_fanout_filter=off'

// 현재 쿼리만 히스토그램을 사용하지 않게 설정
mysql> SELECT /*+ SET_VAR(optimizer_switch='condition_fanout_filter=off') */ * FROM ...

```

<br>

### 히스토그램의 용도

히스토그램 도입 전에도 테이블과 인덱스에 대한 통계 정보는 존재

But, 기존 통계 정보는 테이블의 전체 레코드 건수와 인덱스된 칼럼이 가지고 있는 유니크한 값의 개수 정도

예를 들어 테이블의 레코드가 1000건, 어떤 칼럼의 유니크한 값 개수가 100건이라면

이 칼럼에 대해 다음과 같은 동등 비교 검색을 하면 대략 10개의 레코드가 일치할 것으로 예측

```
mysql> SELECT * FROM order WHERE user_id='matt.lee';
```

<br>

But, `실제 응용 프로그램의 데이터는 항상 균등한 분포를 갖지 않음`

그래서 기존의 통계 정보는 해당 부분을 고려하지 못했음

이런 단점을 보완하기 위해 히스토그램 도입

히스토그램은 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 더 정확한 예측이 가능

<br>

<p align="center"><img src="./images/10_10.png" width="100%"></p>

<br>

<p align="center"><img src="./images/10_11.png" width="100%"></p>

<br>

위의 첫번째 이미지는 옵티마이저는 first_name='Zita' 조건에 일치하는 레코드 224건이 있고, 그 중 대략 11.11%인 24.8명 정도의 birth_date가 1950년대 생으로 예측

두번째 이미지는 히스토그램 정보를 수집하고 동일한 쿼리의 실행 계획을 봤을 때,

대략 61.03%인 136명이 1950년대 생으로 예측

<p align="center"><img src="./images/10_12.png" width="80%"></p>

<br>

실제 데이터를 조회해보면 대략 63.84%인 143명이 1950년대 생이라는 것을 알 수 있음

단순 통계 정보만을 이용한 경우와 히스토그램을 이용한 경우 차이가 매우 큼

<br>

히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있기에 쿼리의 성능에 상당한 영향을 미침

<p align="center"><img src="./images/10_13.png" width="100%"></p>

<br>

위의 예제는 2개의 테이블을 조인하는데 옵티마이저 힌트를 통해 강제로 조인의 순서를 바꿔 성능을 살펴봄

첫번째 쿼리는 employees 테이블을 읽고 salaries 테이블을 조인한 예제

두번째 쿼리는 salaries 테이블을 읽고 employees 테이블을 조인한 예제

### 첫번째 쿼리가 더 빠른 이유는?

조인해야 할 건수가 salaries 테이블을 먼저 읽은 경우보다 훨씬 적음

Why?

birth_date 칼럼과 salary 칼럼은 인덱스되지 않은 칼럼이기에 이 칼럼들의 데이터 분포를 전혀 알지 못하고 실행 계획을 수립

<u>내 생각</u>

두 칼럼이 모두 인덱스가 없기에 풀 테이블 스캔은 필수적

Salary 칼럼이 레코드 수가 더 많고 birth_date 칼럼이 레코드 수가 더 적기에

salary 칼럼이 드라이빙되는 것이 조인하는 횟수가 훨씬 적음

<u>검증</u>

<p align="center"><img src="./images/10_14.png" width="100%"></p>

<br>

생각이 맞았고, birth_date가 0개 였기에 empty set이었음

이러한 차이로 쿼리의 성능은 10배 차이를 보일 수 있으며, InnoDB 버퍼 풀에 데이터가 존재하지 않아서 디스크에서 데이터를 읽어야 하는 경우라면 몇 배의 차이 발생

`결국 각 칼럼에 대해 히스토그램 정보가 있으면 어느 테이블을 먼저 읽어야 조인의 횟수를 줄일 수 있을지 옵티마이저가 더 정확하게 판단 가능`

<br>

### 히스토그램과 인덱스

히스토그램과 인덱스는 완전히 다른 객체이기에 서로 비교할 대상은 아니지만,

인덱스는 부족한 통계 정보를 수집하기 위해 사용되는 측면에서 어느 정도 공통점을 가짐

쿼리의 실행 계획을 수립할 때 

<u>사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고

최종적으로 가장 나은 실행 계획을 선택</u>

이 때 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴봄

이 작업을 인덱스 다이브(Index dive)라고 표현

<br>

쿼리의 검색 조건으로 많이 사용되는 컬럼에 대해서는 일반적으로 인덱스를 생성

이렇게 인덱스된 칼럼에 대해 히스토그램 정보를 수집해두는 것이 좋을까?

```
mysql> SELECT *
        FROM employees
        WHERE first_name='Tonny'
        AND birth_date BETWEEN '1954-01-01' AND '1955-01-01';
```

해당 쿼리에서 옵티마이저는 테이블 풀 스캔을 할지, first_name 인덱스를 이용할지 고민

birth_date 칼럼에는 인덱스가 없으므로 해당 칼럼은 실행 계획에 큰 영향을 미치지 않을 것

<br>

<u>first_name 칼럼에 히스토그램이 수집되어 있었다면 옵티마이저는 해당 내용을 이용할까?</u>

사용하지 않음

실제 인덱스 다이브를 통해 직접 수집한 정보를 활용

`이는 실제 검색 조건의 대상 값에 대한 샘플링을 실행하는 것이기에 히스토그램보다 정확한 결과를 기대할 수 있기 때문`

`그래서 8.0 버전에서 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포를 참조하는 용도로 사용`

<br>

### 코스트 모델

MySQL 서버가 쿼리를 처리하려면 다음과 같은 다양한 작업 필요

- 디스크로부터 데이터 페이지 읽기

- 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기

- 인덱스 키 비교

- 레코드 평가

- 메모리 임시 테이블 작업

- 디스크 임시 테이블 작업

<br>

MySQL 서버는 사용자의 쿼리에 대해 이런 작업들이 얼마나 필요한지 예측하고 전체 작업 비용을 계산한 결과를 바탕으로 최적의 실행 계획을 찾음

이렇게 `전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용을 코스트 모델(Cost Model)`이라고 함

5.7 버전까지는 이런 비용들을 서버 소스 코드에 상수화해서 사용

근데 해당 비용들은 서버가 사용하는 하드웨어에 따라 달라질 수 있기에 예전 버전처럼 고정된 비용을 적용하는 것은 최적의 실행 계획 수립에 있어서 방해 요소

<br>

해당 단점을 보완하기 위해 5.7 버전부터 상수화돼 있던 각 단위 작업의 비용을 DBMS 관리자가 조정할 수 있도록 개선

하지만 해당 버전에서는 인덱스되지 않은 칼럼의 히스토그램이나 메모리에 상주 중인 페이지의 비율 등 비용 계산과 연관 부분 정보들이 부족한 상태

8.0 버전으로 업그레이드되면서 해당 이슈가 해소되고 옵티마이저 실행 계획 수립에 사용되기 시작

<br>

코스트 모델은 다음 2개 테이블에 저장돼 있는 설정값을 사용하는데, 두 테이블 모두 mysql DB에 존재

- server_cost : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리

- engine_cost : 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리

<br>

두 테이블은 공통으로 5개의 칼럼을 갖고 있음

- cost_name

    코스트 모델의 각 단위 작업

- default_value

    각 단위 작업의 비용 (기본값이며, 이 값은 서버 소스 코드에 설정된 값)

- cost_value

    DBMS 관리자가 설정한 값 (이 값이 NULL이면 MySQL 서버는 default_value 칼럼의 비용 사용)

- last_updated

    단위 작업의 비용이 변경된 시점

    옵티마이저에 영향을 미치는 정보 X, 단순 정보성

- comment

    비용에 대한 추가 설명

    옵티마이저에 영향을 미치는 정보 X, 단순 정보성

<br>

engine_cost는 2개의 칼럼을 더 가지고 있음

- engine_name

    비용이 적용된 스토리지 엔진

- device_type

    디스크 타입

<br>

코스트 모델에서 지원하는 단위 작업은 다음과 같음

|             | cost_name                    | default_value | 설명 |
|-------------|------------------------------|---------------|---|
| engine_cost | io_block_read_cost           |          1.00 | 디스크 데이터 페이지 읽기 |
|             | memory_block_read_cost       |          0.25 | 메모리 데이터 페이지 읽기 |
| server_cost | disk_temptable_create_cost   |         20.00 | 디스크 임시 테이블 생성  |
|             | disk_temptable_row_cost      |          0.50 | 디스크 임시 테이블의 레코드 읽기  |
|             | key_compare_cost             |          0.05 | 인덱스 키 비교 |
|             | memory_temptable_create_cost |          1.00 | 메모리 임시 테이블 생성  |
|             | memory_temptable_row_cost    |          0.10 | 메모리 임시 테이블의 레코드 읽기 |
|             | row_evaluate_cost            |          0.10 | 레코드 비교 |


```
### 디스크 임시 테이블 생성을 하는 이유

MySQL에서 임시 테이블을 생성하는 실행 계획이 나오는 이유는 다양합니다. 가장 일반적인 이유는 다음과 같습니다:

임시 테이블 필요성: 쿼리 실행 중에 중간 결과를 저장하거나 정렬된 데이터를 임시로 보관해야 할 때 임시 테이블이 필요할 수 있습니다. 예를 들어, 대용량의 데이터를 정렬하거나 복잡한 조인을 수행하는 경우 임시 테이블을 사용하여 중간 결과를 저장할 수 있습니다.
메모리 부족: 쿼리 실행 중에 메모리가 부족한 경우 MySQL은 디스크에 임시 테이블을 생성하여 데이터를 저장할 수 있습니다. 이는 일시적으로 메모리 부족 상태를 해결하고 쿼리를 완료할 수 있도록 합니다.
임시 테이블 크기 제한: MySQL은 메모리에서 관리되는 임시 테이블의 크기에 제한을 둘 수 있습니다. 이 제한을 초과하는 경우 MySQL은 디스크에 임시 테이블을 생성하여 추가적인 데이터를 저장합니다.
정렬 및 그룹화: 정렬이나 그룹화된 결과를 생성하는 경우, MySQL은 임시 테이블을 사용하여 중간 결과를 저장하고 처리할 수 있습니다.
```

`row_evaluate_cost는 스토리지 엔진이 반환한 레코드가 쿼리의 조건에 일치하는지를 평가`하는 단위 작업

해당 값이 증가할수록 풀 테이블 스캔과 같이 많은 레코드를 처리하는 쿼리의 비용이 높아지고 

반대로 레인지 스캔과 같이 상대적으로 적은 수의 레코드를 처리하는 쿼리의 비용이 낮아짐

<br>

key_compare_cost는 키 값의 비교 작업에 필요한 비용을 의미하는데

해당 값이 증가할수록 레코드 정렬과 같이 키 값 비교 처리가 많은 경우 쿼리의 비용이 높아짐

<br>

<p align="center"><img src="./images/10_15.png" width="100%"></p>

<br>

옵티마이저는 

인덱스의 B-Tree 깊이, 

인덱스 키 검색을 위해 읽어야 하는 페이지 개수,

디스크와 메모리에서 데이터 페이지를 각각 몇 개씩 읽어야 하는지,

레코드 정렬 작업에서 사용되는 알고리즘별로 키 값 비교 작업이 몇 번 필요한지,

등을 통해 쿼리의 비용이 계산되기에 직접 계산하는 것은 상당히 어려움

<br>

`코스트 모델에서 중요한 것은 각 단위 작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고 어떤 실행 계획들이 저비용으로 바뀌는지를 파악하는 것`

대표적으로 각 단위 작업의 비용이 변경되면 예상할 수 있는 결과들은 다음과 같음

(이것이 영향의 전부는 아니지만 코스트 모델을 이해하고 비용 조절을 연습해볼 수 있는 기준은 될 것)

- key_compare_cost(인덱스 키 비교) 비용을 높이면 MySQL 서버 옵티마이저가 가능하면 정렬을 수행하지 않는 방향의 실행 계획을 선택할 가능성이 높아짐

- row_evaluate_cost(레코드 비교) 비용을 높이면 풀 스캔을 실행하는 쿼리들의 비용이 높아지고, MySQL 서버 옵티마이저가 가능하면 인덱스 레인지 스캔을 사용하는 실행 계획을 선택할 가능성이 높아짐

- disk_temptable_create_cost(디스크 임시 테이블 생성)와 disk_temptable_row_cost(디스크 임시 테이블의 레코드 읽기) 비용을 높이면 옵티마이저는 디스크에 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아짐

- io_block_read_cost(디스크 데이터 페이지 읽기) 비용이 높아지면 옵티마이저는 가능하면 InnoDB 버퍼 풀에 데이터 페이지가 많이 적재돼 있는 인덱스를 사용하는 실행 계획을 선택할 가능성이 높아짐

- memory_block_read_cost(메모리 데이터 페이지 읽기) 비용이 높아지면 InnoDB 버퍼 풀에 적재된 데이터 페이지가 상대적으로 적다고 하더라도 그 인덱스를 선택할 가능성이 높아짐

<br>

## 10.2 실행 계획 확인

MySQL 서버의 실행 계획은 DESC or EXPLAIN 명령으로 확인

8.0 버전부터는 EXPLAIN 명령에 사용할 수 있는 새로운 옵션 추가

<br>

### 실행 계획 출력 포맷

8.0 버전부터 FORMAT 옵션을 사용해 실행 계획의 표시 방법을 JSON, TREE, 단순 테이블 형태로 선택 가능

- 테이블 포맷

    <p align="center"><img src="./images/10_16.png" width="100%"></p>

<br>

- 트리 포맷

    <p align="center"><img src="./images/10_17.png" width="100%"></p>

<br>

- JSON 포맷

    <p align="center"><img src="./images/10_18.png" width="80%"></p>

<br>

포맷별 개인 선호도나 표시되는 정보의 차이는 있지만 옵티마이저가 수립한 실행 계획의 큰 흐름을 보여주는 데는 큰 차이가 없음

<br>

### 쿼리의 실행 시간 확인

8.0.18 버전부터 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 EXPLAIN ANALYZE 기능 추가

EXPLAIN ANALYZE 명령은 항상 TREE 포맷

<p align="center"><img src="./images/10_19.png" width="100%"></p>

<br>

질문

`실행계획을 살펴보면 Index lookup on s using PRIMARY가 가장 안쪽으로 들여써져 있는데 왜 이 문장이 먼저 해석이 안되는지?`

MySQL의 실행 계획에서 들여쓰기(indentation)는 실행 순서를 명확히 나타내기 위한 것이 아니라, 실행 단계 간의 관계를 보여주기 위한 것

특히, 중첩 루프 조인(Nested Loop Join)과 같은 경우, 각 테이블에 대한 접근이 중첩된 방식으로 이루어지기 때문에 이러한 들여쓰기가 사용

이는 MySQL 옵티마이저가 각 단계에서 어떤 작업을 수행하는지를 설명하는 데 중점

### 들여쓰기와 실행 순서의 관계

실행 계획에서 들여쓰기는 각 단계의 작업이 다른 단계와 어떻게 연결되어 있는지를 나타내며, 반드시 위에서 아래로의 순서대로 실행되는 것을 의미하지는 않음

대신, MySQL 옵티마이저는 각 단계의 상호 작용을 설명

### 실행 계획 순서

`EXPLAIN ANALYZE`의 결과를 살펴보면:

```sql
EXPLAIN ANALYZE SELECT e.emp_no, avg(s.salary)
FROM employees e
INNER JOIN salaries s ON s.emp_no = e.emp_no
AND s.salary > 50000
AND s.from_date <= '1990-01-01'
AND s.to_date > '1990-01-01'
WHERE e.first_name = 'Matt'
GROUP BY e.emp_no, e.hire_date \G
```

### 실행 계획의 각 단계

1. **Index lookup on e using ix_first_name (first_name='Matt')**
   - `employees` 테이블에서 `first_name`이 'Matt'인 행을 찾습니다. 이는 `ix_first_name` 인덱스를 사용합니다.
   - 이 단계는 첫 번째로 수행됩니다. 왜냐하면 조인 조건에서 `e.emp_no`를 기반으로 `salaries` 테이블과 조인하기 전에 `employees` 테이블에서 적합한 행을 찾는 작업이 필요하기 때문입니다.

2. **Index lookup on s using PRIMARY (emp_no=e.emp_no)**
   - `salaries` 테이블에서 `emp_no`가 `employees` 테이블의 `emp_no`와 일치하는 행을 찾습니다. 이는 `PRIMARY` 키 인덱스를 사용합니다.
   - 이 단계는 `employees` 테이블에서 찾은 각 행에 대해 수행됩니다. 즉, 첫 번째 단계에서 찾은 `e.emp_no` 값을 기반으로 `salaries` 테이블을 검색합니다.

3. **Filter: ((s.salary > 50000) and (s.from_date <= DATE '1990-01-01') and (s.to_date > DATE '1990-01-01'))**
   - `salaries` 테이블에서 추가적인 조건(`salary`, `from_date`, `to_date`)을 만족하는 행을 필터링합니다.
   - 이 단계는 두 번째 단계에서 찾은 행들에 대해 적용됩니다.

4. **Nested loop inner join**
   - `employees` 테이블과 `salaries` 테이블을 중첩 루프 방식으로 조인합니다.
   - 이 단계는 첫 번째와 두 번째 단계의 결과를 조합합니다.

5. **Aggregate using temporary table**
   - 임시 테이블을 사용하여 집계 연산을 수행합니다.
   - 조인된 결과를 기반으로 집계를 수행합니다.

6. **Table scan on <temporary>**
   - 임시 테이블에서 테이블 스캔을 수행하여 최종 결과를 반환합니다.

### 왜 Index lookup on s using PRIMARY가 먼저 해석되지 않는가?
실제 실행 순서는 쿼리의 논리적 순서와 맞물려 있습니다. 

`employees` 테이블에서 먼저 필터링하고, 그 결과를 `salaries` 테이블과 조인하여 추가 조건을 적용합니다.

비록 `Index lookup on s using PRIMARY`가 들여쓰기로 인해 안쪽에 위치해 있지만, 이는 `employees` 테이블에서 필터링된 결과를 바탕으로 수행되는 하위 단계임을 나타냅니다. 

다시 말해, `employees` 테이블에서 `first_name='Matt'`인 행을 찾는 것이 첫 번째 단계이며, 그 후에 이 행을 기반으로 `salaries` 테이블을 검색하고 필터 조건을 적용하는 것이 논리적 순서입니다. 

들여쓰기는 이러한 관계를 시각적으로 표현하기 위한 것이며, 실제 실행 순서는 옵티마이저가 결정한 논리적 순서대로 진행됩니다.

<br>

실행 계획애 나열된 필드들의 의미

- actual time

    쿼리 실행의 각 단계에서 소요된 실제 시간 (해당 단계가 시작되기까지 걸린 시간, 완료될 때까지의 시간)

<br>

- rows

    해당 단계에서 처리된 행(row)의 수

<br>

- loops

    해당 단계가 몇 번 반복되었는지

<br>

<p align="center"><img src="./images/10_19.png" width="100%"></p>

<br>

1. employees 테이블을 index firstname으로 1회 반복하면서 스캔했고 233개 행을 찾았음 첫번째 레코드를 찾는 데에 0.331초가 걸렸으며 마지막 레코드를 찾는 데에는 총 0.775초가 걸렸음

2. 그 찾은 233개의 행에서 1행씩 꺼내와서 emp_no를 salaries 테이블의 emp_no와 매칭한 레코드들을 평균 9.53개 가져왔고 총 233개 행이니까 233회 반복 

    <br>

    <p align="center"><img src="./images/10_20.png" width="50%"></p>

    <br>

    emp_no가 497766인 값의 레코드들을 추출했을 때 15개가 나왔음
    
    이런 식으로 emp_no가 일치하는 레코드들의 평균 값이 9.53개라는 뜻

3. 동시에 filter(salary>50000, from_date가 90년 1월 1일 전부터 to_date가 90년 1월 1일 이후까지)까지 하면 평균 1 loop에 0.206 행이 추출

4. 이렇게 두 개의 테이블에서 찾은 레코드들을 NL 조인, 총 48행이 추출

5. AVG 함수 때문에 임시 테이블을 생성하고 

6. 임시 테이블을 테이블 스캔하여 결과 반환

<br>

## 실행 계획 분석

실행 계획이 어떤 접근 방식을 사용해서 어떤 최적화를 수행하는지, 그리고 어떤 인덱스를 사용하는지 등을 이해하는 것이 중요

<p align="center"><img src="./images/10_16.png" width="100%"></p>

<br>

표의 각 레코드는 `쿼리 문장에서 사용된 테이블(서브쿼리로 임시 테이블을 생성한 경우 임시 테이블까지 포함)의 개수만큼 출력`

실행 순서는 위에서 아래로 순서대로 표시(UNION이나 상관 서브쿼리와 같은 경우 순서대로 표시 안될수도)

위쪽에 출력된 결과일수록(id 칼럼 값이 작을수록) 쿼리의 바깥 부분이거나 먼저 접근한 테이블

아래쪽에 출력된 결과일수록(id 칼럼 값이 클수록) 쿼리의 안쪽 부분이거나 나중에 접근한 테이블

<br>

### id 칼럼

하나의 SELECT 문장은 다시 1개 이상의 하위 SELECT 문장을 포함할 수 있음

```sql
SELECT ...
FROM (SELECT ... FROM tb_test1) tb1, tb_test2 tb2
WHERE tb1.id=tb2.id;
```

해당 쿼리에 있는 각 SELECT를 분리해서 생각해보자

SELECT 키워드 단위로 구분한 것을 단위(SELECT) 쿼리라고 함

```sql
SELECT ... FROM tb_test1;
SELECT ... tb1, tb2 WHERE tb1.id=tb2.id;
```

실행 계획에서 가장 왼쪽에 표시되는 `id 칼럼은 단위 SELECT 쿼리별로 부여되는 식별자 값`

위의 쿼리의 경우 실행 계획에서 최소 2개의 id 값이 표시

또한,

`하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 코드가 출력되지만 같은 id 값이 부여`

<p align="center"><img src="./images/10_21.png" width="90%"></p>

<br>

각기 다른 id 값의 예제

<p align="center"><img src="./images/10_22.png" width="90%"></p>

<br>

`id 칼럼이 테이블의 접근 순서를 의미하지는 않음`

<p align="center"><img src="./images/10_24.png" width="90%"></p>

<p align="center"><img src="./images/10_23.png" width="90%"></p>

<br>

위의 실행 계획을 살펴보면 dept_emp 테이블의 id가 1이고, employees 테이블의 id가 2지만

실제 쿼리의 실행 순서는 employees 테이블을 먼저 읽고 그 결과를 이용해 dept_emp 테이블을 읽는 순서로 실행

FORMAT=TREE 명령으로 확인해보면 순서를 정확히 알 수 있음

<p align="center"><img src="./images/10_25.png" width="90%"></p>

<br>

```
근데 왜 emp_no라는 PK 인덱스가 존재하는데 ix_empno_fromdate로 index lookup을 했을까?

인덱스 선택 이유

복합 인덱스 활용: 

ix_empno_fromdate는 emp_no와 from_date 컬럼을 포함하는 복합 인덱스입니다. 복합 인덱스는 단일 인덱스보다 효율적으로 사용할 수 있으며, 옵티마이저가 더 효율적이라고 판단했을 수 있습니다.


카디널리티와 조건 일치: 

ix_empno_fromdate 인덱스의 카디널리티가 높거나, 해당 인덱스가 조건에 더 잘 맞는다고 판단되었을 수 있습니다.


추가 조건 대비: 

쿼리에서 추가 조건이나 정렬 조건이 존재한다면, 복합 인덱스가 이를 더 잘 처리할 수 있습니다. 예를 들어, 향후 from_date 조건이 추가될 가능성을 염두에 두고 인덱스를 선택했을 수 있습니다.


인덱스 스캔 비용: 

인덱스 스캔 비용이 더 낮게 평가되었을 수 있습니다. 옵티마이저는 각 인덱스를 평가할 때, 이를 사용하는 비용을 계산하여 가장 저렴한 경로를 선택합니다.

근데 카디널리티도 emp_no가 더 높은데 왜지
```

<br>

### select_type 칼럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼

### SIMPLE

UNION이나 서브 쿼리를 사용하지 않는 단순 SELECT 쿼리인 경우 SIMPLE로 표시(쿼리에 조인이 포함된 경우도 마찬가지)

쿼리 문장이 아무리 복잡하더라도 SIMPLE인 단위 쿼리는 하나만 존재

일반적으로 제일 바깥 SELECT 쿼리가 SIMPLE로 표시

<br>

### PRIMARY

UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 잇는 단위 쿼리는 PRIMARY로 표시

<br>

### UNION

UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 select_type은 UNION으로 표시

UNION의 첫 번째 단위 SELECT는 select_type이 UNION이 아니라 UNION되는 쿼리 결과들을 모아서 저장하는 임시 테이블(DERIVED)이 select_type으로 표시

<p align="center"><img src="./images/10_26.png" width="90%"></p>

<br>

UNION이 되는 단위 SELECT 쿼리 3개 중에서 첫 번째(e1 테이블)만 UNION이 아니고, 나머지 2개는 모두 UNION으로 표시돼 있음

대신 UNION의 첫 번째 쿼리는 전체 UNION의 결과를 대표하는 select_type으로 설정

세 개의 서브쿼리로 조회된 결과를 UNION ALL로 결합해 임시 테이블을 만들어서 사용하고 있으므로 UNION ALL의 첫 번째 쿼리는 DERIVED라는 select_type을 가짐

<br>

### DEPENDENT UNION * 어려움

DEPENDENT UNION 또한 UNION select_type과 같이 UNION이나 UNION ALL로 집합을 결합하는 쿼리에서 표시

여기서 DEPENDENT는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미

<br>

다음 예제 쿼리를 보면 두 개의 SELECT 쿼리가 UNION으로 결합됐으므로 select_type에 UNION이 표시된 것을 알 수 있음

IN 이하 서브 쿼리에서는 두 개의 쿼리가 UNION으로 연결된 것을 확인할 수 있음

예제 쿼리의 경우 옵티마이저가 IN 내부의 서브 쿼리를 먼저 처리하지 않고, 외부의 employees 테이블을 먼저 읽은 다음 서브 쿼리를 실행하는데 이때 employees 테이블의 칼럼값이 서브쿼리에 영향을 줌

이렇게 내부 쿼리가 외부의 값을 참조해서 처리될 때 DEPENDENT 키워드가 표시

<p align="center"><img src="./images/10_27.png" width="90%"></p>

<br>

결국 내부적으로 UNION에 사용된 SELECT 쿼리의 WHERE 조건에 e2.emp_no=e1.emp_no와 e3.emp_no=e1.emp_no라는 조건이 자동으로 추가되어 실행

외부에 정의된 employees 테이블의 emp_no 칼럼이 서브쿼리에 사용되기 때문에 DEPENDENT UNION이 표시

<br>

### UNION RESULT

UNION RESULT는 UNION 결과를 담아두는 테이블을 의미

8.0 이전 버전에서는 UNION ALL이나 UNION 쿼리는 모두 UNION의 결과르 임시 테이블로 생성했는데

8.0 버전부터는 UNION ALL의 경우 임시 테이블을 사용하지 않도록 기능이 개선

하지만 UNION은 8.0 버전에서도 여전히 임시 테이블에 결과를 버퍼링

```
### UNION과 UNION ALL의 차이

SQL에서 두 개 이상의 결과 집합을 결합할 때 사용하는 연산자 두 연산자 모두 행을 결합

UNION은 중복을 제거하기에 추가적인 정렬과 비교 작업이 필요

UNION ALL은 중복이 허용되기에 UNION보다 성능이 좋음
```

실행 계획상에서 임시 테이블을 가리키는 것이 UNION RESULT

UNION RESULT는 실제 쿼리에서 단위 쿼리가 아니기에 별도의 id 값은 부여되지 않음

<p align="center"><img src="./images/10_28.png" width="90%"></p>

<br>

마지막 값의 경우 table 칼럼이 <union 1,2>로 표시되어 있는데 이것은 id 값이 1인 단위 쿼리의 조회 결과와 2인 조회 결과를 UNION했다는 것을 의미

<p align="center"><img src="./images/10_29.png" width="90%"></p>

<br>

UNION ALL을 사용하면 임시 테이블에 버퍼링하지 않기에 UNION RESULT가 없어진 것을 확인 가능

<br>

### SUBQUERY

select_type의 SUBQUERY는 FROM 절 이외에서 사용되는 서브쿼리만을 의미

<p align="center"><img src="./images/10_30.png" width="90%"></p>

<br>

FROM 절에 사용된 서브쿼리는 DERIVED라고 표시되고 그 밖의 위치에서 사용된 서브 쿼리는 전부 SUBQUERY라고 표시

<br>

쿼리 해석

emp_no=10001인 레코드의 first_name을 적고, 서브쿼리의 결과 값을 적으면 됨

각자 별개의 쿼리로 동작하는 것

<p align="center"><img src="./images/10_31.png" width="90%"></p>

<br>

### DEPENDENT SUBQUERY

서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경우, select_type에 DEPENDENT SUBQUERY라고 표시

<p align="center"><img src="./images/10_32.png" width="90%"></p>

<br>

employees 테이블에서 first_name가 Matt인 레코드의 first_name을 select
dept_manager, dept_emp 테이블에서 dept_no가 같고, dept_emp, employees 테이블의 emp_no가 같은 레코드들을 추출해서 다 전부 count

서브쿼리에서 dept_manager와 dept_emp 테이블을 결합하여 dept_no를 기준으로 de.emp_no가 e.emp_no와 같은 행을 찾고 카운트를 계산

<br>

안쪽의 서브쿼리 결과가 바깥쪽 SELECT 쿼리의 칼럼에 의존적이기 때문에 DEPENDENT라는 키워드가 붙음

또한, 외부 쿼리가 먼저 수행된 후 내부 쿼리(서브 쿼리)가 실행되야 하므로 일반 서브 쿼리보다는 처리 속도가 느릴 때가 많음

<br>

### DERIVED

5.5 버전까지는 서브쿼리가 FROM 절에 사용된 경우 항상 DERIVED인 실행 계획을 만듦

5.6 버전부터는 옵티마이저 옵션(optimizer_switch)에 따라 FROM 절의 서브쿼리를 외부 쿼리와 통합하는 형태의 최적화가 수행

DERIVED는 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블(파생 테이블)을 생성하는 것을 의미

5.6 버전부터는 옵티마이저 옵션에 따라 쿼리의 특성에 맞게 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화됨

<p align="center"><img src="./images/10_33.png" width="90%"></p>

<br>

FROM 절의 서브쿼리를 임시 테이블로 만들어 처리

8.0 버전부터 FROM 절의 서브쿼리에 대한 최적화도 많이 개선되어 가능하다면 불필요한 서브 쿼리는 조인으로 쿼리를 재작성해서 처리

`쿼리를 튜닝하기 위해 실행 계획을 확인할 때 가장 먼저 select_type 칼럼 값이 DERIVED인 것이 있는지 확인`

서브쿼리를 조인으로 해결할 수 있는 경우라면 서브 쿼리보다는 조인을 사용

<br>

### DEPENDENT DERIVED 

8.0 이전 버전에서는 FROM 절의 서브쿼리는 외부 칼럼을 사용할 수가 없었는데 

8.0 버전부터는 래터럴 조인 기능이 추가되면서 FROM 절의 서브쿼리에서도 외부 칼럼을 참조할 수 있게 됨

다음 쿼리는 래터럴 조인의 대표적인 예제로 employees 테이블의 레코드 1건당 salaries 테이블의 레코드를 최근 순서대로 최대 2건까지만 가져와서 조인을 실행

<p align="center"><img src="./images/10_34.png" width="90%"></p>

<br>

### UNCACHEABLE SUBQUERY

하나의 쿼리 문장에 서브쿼리가 하나만 있더라도 실제 그 서브쿼리가 한 번만 실행되는 것은 아님

그런데 조건이 똑같은 서브쿼리가 실행될 때는 내부적인 캐시 공간에 담아둠

