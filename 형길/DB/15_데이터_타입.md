# 15장. 데이터 타입

칼럼의 데이터 타입을 선정하는 작업은 물리 모델링에서 빼놓을 수 없는 작업

칼럼의 `데이터 타입과 길이를 선정할 때` 가장 주의할 사항

- 저장되는 값의 성격에 맞는 최적의 타입을 선정

- 가변 길이 칼럼(ex. VARCHAR)은 최적의 길이를 지정

- 조인 조건으로 사용되는 칼럼은 똑같은 데이터 타입으로 선정

<br>

칼럼의 데이터 타입을 선정할 때 실제 저장되는 `값의 특성을 고려하지 않고 가능한 최대 길이 값을 기준으로 칼럼의 길이를 선택하는 것이 일반적`

하지만 무분별하게 칼럼의 길이가 크게 선정되면 디스크의 공간은 물론 메모리나 CPU의 자원도 함께 낭비

<br>

## 문자열(CHAR와 VARCHAR)

문자열 칼럼을 사용할 때는 우선 CHAR 타입과 VARCHAR 타입 중 어떤 타입을 사용할지 결정

`CHAR와 VARCHAR 타입의 차이가 무엇이고 어떤 타입을 사용하는 것이 좋은가에 관한 질문`

지금까지 모든 DBMS가 CHAR나 VARCHAR `타입을 구분해서 제공하는 것을 보면 그만큼의 장단점이 있을 것`

### 저장 공간

CHAR와 VARCHAR의 공통점은 문자열을 저장할 수 있는 데이터 타입이라는 점

`가장 큰 차이는 고정 길이냐 가변 길이냐`

- 고정 길이는 실제 입력되는 칼럼값의 길이에 따라 사용하는 저장 공간의 크기가 변하지 않음

    CHAR 타입은 이미 저장 공간 크기가 고정적, 실제 저장된 값의 유효 크기가 얼마인지 별도로 저장할 필요가 없음

- 가변 길이는 최대로 저장할 수 있는 값의 길이는 제한돼 있지만, 그 이하 크기의 값이 저장되면 그만큼 저장 공간이 줄어듬

    하지만 `저장된 유효 크기가 얼마인지 별도로 저장해 둬야 하므로 1~2 바이트의 저장 공간이 추가로 더 필요`

<br>

하나의 글자를 저장하기 위해 CHAR(1)과 VARCHAR(1) 타입을 사용할 때 실제 사용되는 저장 공간의 크기를 살펴보자

`두 문자열 타입 모두 한 글자를 저장할 떄 사용하는 문자 집합에 따라 실제 저장 공간을 1 ~ 4 바이트까지 사용`

여기에다가 VARCHAR 타입은 문자열의 길이를 관리하기 위한 1 ~ 2 바이트의 공간을 추가로 더 사용

VARCHAR 타입의 길이가 255바이트 이하이면 1바이트만 사용하고, 256바이트 이상으로 설정되면 2바이트를 사용

VARCHAR 타입의 최대 길이는 2바이트로 표현할 수 있는 이상은 사용할 수 없음

무슨 소리냐 즉, VARCHAR 타입의 최대 길이는 65,536 바이트 이상으로 설정할 수 없음

> 65536의 의미는 64KB, 2의 15제곱, 16진수의 ffff가 66535, 16자리의 bit가 표현될 수 있는 가지 수가 65536

> 만약 인코딩이 cp949, euc-kr이라면 한글 바이트는 2바이트이기에 띄어쓰기,엔터,특수문자 없이 순수 한글만 32768개 사용 가능

<br>

    MySQL에서는 하나의 레코드에서 TEXT와 BLOB 타입을 제외한 칼럼의 전체 크기가 64KB를 초과할 수 없음

    테이블에 VARCHAR 타입의 칼럼 하나만 있다면 최대 64KB, 다른 칼럼에서 40KB를 사용하고 있다면 VARCHAR는 24KB 사용 가능

    24KB를 초과하는 크기의 VARCHAR 타입을 생성하려고 하면 에러가 발생하거나 자동으로 TEXT 타입으로 대체

    그래서 칼럼을 새로 추가할 때는 TEXT 타입으로 자동으로 변환되지 않았는지 확인해 보는 것이 좋음

    
    
    1문자는 문자 집합에 따라서 1 ~ 4 바이트까지 공간을 사용할 수 있기 때문에 1문자와 1바이트를 구분해서 사용


<br>

왜 길이가 고정적일 때 CHAR를 사용하면 좋을까?

VARCHAR 타입을 선택해도 기껏 1 ~ 2바이트만 더 사용할 뿐인데 이렇게 고민해가면서 시간을 투자할 가치가 있는 것일까?

실제 문자열 값의 길이가 정적이냐 가변적이냐만으로 CHAR와 VARCHAR 타입을 결정하는 것은 적절치 않음

CHAR 타입과 VARCHAR 타입을 결정할 때 중요한 판단 기준

- 저장되는 문자열의 길이가 대개 비슷한가?

- 칼럼의 값이 자주 변경되는가?

`즉, CHAR과 VARCHAR 타입의 선택 기준은 값의 길이도 중요하지만, 해당 칼럼의 값이 얼마나 자주 변경되는냐가 기준이 돼야 함`

<br>

<p align="center"><img src="./images/15_1.png" width="90%"></p>

<p align="center"><img src="./images/15_2.png" width="60%"></p>

<br>

tb_test 테이블에 레코드 1건을 저장하면 내부적으로 디스크에는 15.1과 같이 저장

fd1 칼럼은 INTEGER 타입이므로 고정 길이로 4바이트를 사용

fd3 또한 DATETIME이므로 고정 길이로 8바이트를 사용

<br>

`fd2 칼럼은 정확히 10바이트를 사용하면서 앞쪽의 4바이트만 유효한 값으로 채워졌고 나머지는 공백 문자로 채워져 있음`

만약 fd2 칼럼만 VARCHAR(10)으로 변경해서 똑같은 데이터를 저장했을 때 디스크에 어떻게 저장되는지 살펴보자

<p align="center"><img src="./images/15_3.png" width="50%"></p>

<br>

5바이트의 공간을 차지하는데, 첫번째 바이트에는 저장된 칼럼의 유효한 바이트 수인 숫자 4(문자 '4' 아님)가 저장되고 두번째 바이트부터 다섯번째 바이트까지 실제 칼럼값이 저장

`중요한 것은 레코드 한 건이 저장된 상태가 아니라 fd2 칼럼의 값이 변경될 때 어떤 현상이 발생하느냐`

fd2 칼럼의 값을 "ABCDE"로 UPDATE했다고 가정

- CHAR(10) 타입을 사용할 때는 fd2 칼럼을 위해 공간이 10바이트 준비돼 있으므로 그냥 변경되는 칼럼 값을 업데이트만 하면 됨

- VARCHAR(10) 타입을 사용할 때는 fd2 칼럼에 4바이트밖에 저장할 수 없는 구조로 만들어져 있음

    그래서 `"ABCDE"와 같이 길이가 더 큰 값으로 변경될 때는 레코드 자체를 다른 공간으로 옮겨서(Row migration) 저장`해야 함

<br>

주민등록번호처럼 `항상 값의 길이가 고정적일 때는 당연히 CHAR 타입`을 사용

또한, `값이 2 ~ 3 바이트씩 차이가 나더라도 자주 변경될 수 있는 부서 번호나 게시물의 상태 값 등은 CHAR 타입`을 사용하는 것이 좋음

자주 변경돼도 레코드가 물리적으로 다른 위치로 이동하거나 분리되지 않아도 되기 때문

`레코드 이동이나 분리는 CHAR 타입으로 인해 발생하는 2 ~ 3 바이트 공간 낭비보다 더 큰 공간이나 자원을 낭비하게 만듦`


<br>

CHAR나 VARCHAR 키워드 뒤에 인자로 전달하는 숫자 값의 의미를 알아야 함

`다른 DBMS와 다르게 MySQL에서 CHAR나 VARCHAR 뒤에 지정하는 숫자는 그 칼럼의 바이트 수가 아니라 문자의 수를 의미`

그래서 CHAR(10) 타입을 사용하더라도 이 칼럼이 실제로 디스크나 메모리에서 사용하는 공간은 각각 달라짐

- 일반적으로 영어를 포함한 서구권 언어는 각 문자가 1바이트씩 사용하므로 10바이트를 사용

- 한국어나 일본어 같은 아시아권 언어는 각 문자가 최대 2바이트를 사용하므로 20바이트를 사용

- UTF8과 같은 유니코드는 최대 4바이트까지 사용하므로 40바이트까지 사용


#### 참고

<p align="center"><img src="./images/15_4.png" width="90%"></p>

<br>

     UTF8은 한 글자당 최대 3바이트인데 UTF8mb4는 최대 4바이트

     테이블 생성시 기본 설정이 utf8mb4

     5.5 이전 버전에서 주로 사용되던 UTF8

     SMP(Supplementary Multillingual Plane) & SIP(Supplementary Ideographic Plane)... 들이 4바이트 저장 공간을 사용하는데

     이모티콘도 4바이트를 사용

     이모티콘의 발전으로 저장의 필요성이 생겼고 UTF8mb4가 출현

<br>

### 저장 공간과 스키마 변경(Online DDL)

데이터가 변경되는 도중에도 스키마 변경을 할 수 있도록 Online DDL 기능을 제공


> Online DDL은 테이블의 구조를 변경(스키마 변경)을 실행하는 도중에도, INSERT나 UPDATE와 같은 DML들을 실행할 수 있도록 해주는 기능



하지만 모든 스키마 변경이 온라인으로 가능한 것은 아니며, 

변경 작업의 특성에 따라 SELECT나 UPDATE 같은 데이터 변경은 허용되지 않을 수 있음

VARCHAR 데이터 타입을 사용하는 칼럼의 길이를 늘리는 작업은 길이에 따라 매우 빠르게 처리될 수 있지만 

어떤 경우에는 테이블에 대해 읽기 잠금을 걸고 레코드를 복사하는 작업이 필요할 수도 있음

<br>

<p align="center"><img src="./images/15_5.png" width="90%"></p>

<br>

길이가 60으로 정의된 VARCHAR 타입의 칼럼을 가진 테이블에서 확장하는 길이에 따른 ALTER TABLE 명령의 결과를 보면

길이를 63으로 늘리는 경우는 잠금 없이(LOCK=NONE) 매우 빠르게 변경된 것을 확인

길이를 64로 늘리는 경우는 INPLACE 알고리즘으로 스키마 변경이 허용되지 않는다는 것을 알 수 있음

```
제자리(in-place) 알고리즘은 자료 구조를 추가로 사용하지 않고 입력을 변환하는 알고리즘
 
그러나 보통 추가적인 변수를 위해 약간의 추가 저장 공간은 허용
 
n 길이의 리스트가 있고, 이 리스트를 정렬할 때 추가적으로 메모리 공간을 할당하지 않아도 정렬이 이뤄진다면 inplace 알고리즘
```

VARCHAR(64)로 변경하는 경우에는 COPY 알고리즘으로 스키마 변경을 실행했으며, 스키마 변경 시간도 상당히 많이 걸리게 됨

INPLACE 알고리즘의 스키마 변경은 잠금 없이 실행되지만, COPY 알고리즘의 스키마 변경은 읽기 잠금(LOCK=SHARED)까지 필요

즉, 스키마 변경을 하는 동안 test 테이블에는 INSERT, UPDATE, DELETE를 실행할 수 없음

<p align="center"><img src="./images/15_6.png" width="90%"></p>

<br>

이런 차이가 발생하는 이유는 VARCHAR 타입의 칼럼이 가지는 길이 저장 공간의 크기 때문

VARCHAR(60)은 utf8mb4 문자 집합을 사용하는 VARCHAR(60) 칼럼은 최대 길이가 240(60 * 4)바이트이기 때문에 문자열 값의 길이를 저장하는 공간은 1바이트면 ok
(256보다 낮기 때문)

근데 VARCHAR(64)는 저장할 수 있는 문자열의 크기가 최대 256바이트까지 가능하기 때문에 문자열 길이를 저장하는 공간의 코기가 2바이트로 바뀌어야 함

이처럼 문자열 길이를 저장하는 공간의 크기가 바뀌게 되면 MySQL은 스키마 변경을 하는 동안 읽기 잠금을 걸어서 아무도 데이터를 변경하지 못하도록 막고 테이블의 레코드를 복사하는 방식으로 처리

이러한 이유로 `문자열 타입의 칼럼을 설계할 때는 요건이 바뀌어서 VARCHAR 타입의 길이가 크게 변경될 것으로 예상된다면 길이 저장 공간의 크기가 바뀌지 않도록 미리 조금 크게 설계하자`

스키마 변경할 때마다 서비스를 점검 모드로 바꿔야 할 수도 있으므로 이는 서비스의 가용성을 훼손하게 만듦

<br>

### 문자 집합(캐릭터 셋)

`MySQL에서 각 테이블의 칼럼은 모두 서로 다른 문자 집합을 사용해 문자열 값을 저장할 수 있음`

문자 집합은 문자열을 저장하는 CHAR, VARCHAR, TEXT 타입의 칼럼에만 설정 가능

최종적으로는 칼럼 단위로 문자 집합을 관리하지만 관리의 편의를 위해 서버, DB, 테이블 단위로 기본 문자 집합을 설정할 수 있는 기능을 제공

<br>

테이블의 문자 집합을 UTF-8로 설정하면 칼럼의 문자 집합을 별도로 지정하지 않아도 해당 테이블에 속한 칼럼은 UTF-8 문자 집합을 사용

물론 테이블 기본 문자 집합이 있더라도 칼럼별 별도 지정도 가능

<br>

한글 기반의 서비스에서는 euckr or utf8mb4

일본어인 경우에는 cp932 or utf8mb4

한글 윈도우에서 기본적으로 사용되는 MS949 문자 집합은 EUC-KR보다 조금 더 확장된 형태의 문자 집합

유닉스 계열은 CP949

MySQL은 CP949는 지원하지 않고 EUC-KR만 지원

CP949가 EUC-KR보다 더 많은 문자를 표현할 수 있는 문자 집합

하지만 5.5 버전부터 EUC-KR 집합이 보완되어 CP949가 표현하는 모든 문자 집합을 지원하므로 아무런 문제가 없음

<br>

최근의 웹 서비스, 스마트폰 어플리케이션은 여러 나라의 언어를 동시에 지원하기 위해 기본적으로 UTF-8 문자 집합(utf8mb4)을 사용하는 추세

ANSI(미국 표준 협회)에서는 하나의 문자 집합만 기본으로 사용할 수 있는 DB에서 다국어를 지원할 수 있게끔 NCHAR or NATIONAL CHAR와 같은칼럼 타입을 정의

<br>

MySQL 서버에서 사용 가능한 문자 집합은 SHOW CHARACTER SET 명령으로 확인 가능

<p align="center"><img src="./images/15_7.png" width="60%"></p>

<br>

latin 계열의 문자 집합은 알파벳이나 숫자, 키보드의 특수 문자로만 구성된 문자열만 저장해도 될 때 

euckr은 한국어 전용으로 사용되는 문자 집합, 모든 글자는 1 ~ 2바이트 사용

<br>

<p align="center"><img src="./images/15_8.png" width="90%"></p>

<br>

#### 클라이언트로부터 쿼리를 요청했을 때의 문자 집합 변환

서버는 클라이언트로부터 받은 메시지(SQL 문장과 변수값)가 character_set_client에 지정된 문자 집합으로 인코딩돼 있다고 판단하고 

받은 문자열 데이터를 character_set_connection에 정의된 문자 집합으로 변환

```
mysql> SELECT emp_no, first_name FROM employees WHERE first_name = 'Matt';

myslql> SELECT emp_no, first_name FROM employees WHERE first_name = _latin1'Matt';

```

이렇게 SQL 문장에 별도의 문자 집합이 지정된 리터럴(문자열)은 변환 대상에 포함 X

`별도 문자 집합을 설정하는 지정자를 인트로듀서라고 하며 문자열 리터럴 앞에 언더스코어 기호 ( _ )와 문자 집합의 이름을 붙여서 표현`

<br>

#### 처리 결과를 클라이언트로 전송할 때의 문자 집합 변환

character_set_connection에 정의된 문자 집합으로 변환해 SQL을 실행한 다음, 

서버는 쿼리의 결과(결과 set이나 에러 메시지)를 character_set_results 변수에 저장된 문자 집합으로 변환해 클라이언트로 전송

이때 결과 셋에 포함된 칼럼의 값이나 칼럼명과 같은 메타데이터도 모두 character_set_results로 인코딩되어 클라이언트로 전송

<br>

character_set_client, character_set_result, character_set_connection이라는 3개의 시스템 설정 변수에 대해서는 클라이언트 프로그램, 클라이언트 GUI 도구에서 마음대로 변경할 수 있음

이 세가지 변수는 모두 세션 변수이면서 동적 변수

```
mysql> SET character_set_client = 'utf8mb4';
mysql> SET character_set_results = 'utf8mb4';
mysql> SET character_set_connection = 'utf8mb4';

mysql> SET NAMES utf8mb4; // 현재 접속된 커넥션에서만 유효
mysql> CHARSET utf8mb4; // 재시작되지 않은 상태에서 재접속할 때도 문자 집합 설정이 유효하게 만듦
```

<br>

### 콜레이션(Collation)

`콜레이션은 문자열 칼럼의 값에 대한 비교나 정렬 순서를 위한 규칙`

즉, 비교나 정렬 작업에서 영문 대소문자를 같은 것으로 처리할지, 아니면 더 크거나 작은 것으로 판단할지에 대한 규칙을 정의

<br>

MySQL의 모든 문자열 타입의 칼럼은 독립적인 문자 집합과 콜레이션을 가짐

각 칼럼에 대해 독립적으로 문자 집합이나 콜레이션을 지정하든 그렇지 않든 독립적인 문자 집합과 콜레이션을 가지는 것

콜레이션은 문자열 칼럼의 값을 비교하거나 정렬하는 기준이 되기에

각 문자열 칼럼의 값을 비교하거나 정렬할 때는 항상 문자 집합뿐 아니라 콜레이션의 일치 여부에 따라 결과가 달라지며, 쿼리의 성능 또한 상당한 영향을 받음

<br>

#### 콜레이션 이해

문자 집합은 2개 이상의 콜레이션을 가지고 있는데, 하나의 문자 집합에 속한 콜레이션은 다른 문자 집합과 공유해서 사용할 수 X

또한 테이블이나 문자 집합만 지정하면 해당 문자 집합의 디폴트 콜레이션이 해당 칼럼의 콜레이션으로 지정

반대로 콜레이션만 지정하면 해당 콜레이션이 소속된 문자 집합이 묵시적으로 그 칼럼의 문자 집합으로 사용

<p align="center"><img src="./images/15_9.png" width="70%"></p>

<br>

일반적으로 콜레이션의 이름은 2개 또는 3개의 파트로 구분돼 있으며 다음과 같은 의미가 있음

- 3개의 파트로 구성된 콜레이션 이름

    - 첫번째 파트는 문자 집합의 이름

    - 두번째 파트는 해당 문자 집합의 하위 분류

    - 세번째 파트는 대문자나 소문자의 구분 여부
    
        - ci이면 대소문자를 구분하지 않는 콜레이션

        - cs이면 대소문자를 구분하는 콜레이션

<br>

- 2개의 파트로 구성된 콜레이션 이름

    - 첫번째 파트는 문자 집합의 이름

    - 두번째 파트는 bin이라는 키워드 사용

        여기서 bin은 이진 데이터를 의미하는데 이진 데이터로 관리되는 문자열 칼럼은 별도의 콜레이션을 가지지 않음

        콜레이션이 xxx_bin 이라면 비교 및 정렬은 실제 문자 데이터의 바이트 값을 기준으로 수행

<br>

디폴트 문자 집합인 utf8mb4 문자 집합의 콜레이션 중에서 utf8mb4_0900 으로 시작하는 콜레이션에서 "0900"은 UCA(Unicode Collation Algorithm)의 버전을 의미

UCA는 문자 비교 규칙이라고 이해

<br>

utf8mb4 문자 집합에서는 액센트 문자의 구분 여부가 콜레이션의 이름에 포함

이는 ai(액센트를 가지지 않은 문자), as(액센트를 가진 문자)로 나뉘어지고 이걸 가지고 정렬 순서상 동일 문자로 판단할지 여부를 나타냄

<p align="center"><img src="./images/15_10.png" width="30%"></p>

<br>

ai 라면 해당 5개의 글자는 정렬 순서상 동일하게 취급

`여기서 주의할 점은 콜레이션이 정렬 순서에만 영향을 미치는 것이 아니라 동일 문자인지 아닌지의 검색 결과에도 영향을 미친다는 점`

MySQL 서버는 인코딩된 상태로 저장된 문자열을 가져와 각 인코딩된 바이트 값에 해당하는 콜레이션 값으로 매칭시킨 다음 비교를 수행하게 됨

즉, 저장된 문자열의 바이트 값은 직접적인 비교 대상이 아님

<br>

일반적으로 각 국가의 언어는 그 나라 국민에게 익숙한 순서대로 문자 코드 값이 부여돼 있으므로 대소문자를 구분할 때는 _bin 계열의 콜레이션을 적용해도 특별히 문제되진 않음


<br>

문자열 칼럼의 정렬이나 비교는 항상 해당 문자열 칼럼의 콜레이션에 의해 판단하므로 문자열 칼럼에서는 CHAR나 VARCHAR 같은 타입의 이름과 길이만 같다고 해서 똑같은 타입이라고 판단해서는 안됨

타입의 이름 = 문자열의 길이 = 문자 집합 = 콜레이션까지 일치해야 똑같은 타입

`조인을 수행하는 양쪽 테이블의 칼럼이 문자 집합이나 콜레이션이 다르면 비교 작업에서 콜레이션의 변환이 필요하기에 인덱스를 효율적으로 이용하지 못할 때가 많으니 주의`

<br>

<p align="center"><img src="./images/15_11.png" width="90%"></p>

<br>

테이블을 생성할 때 문자 집합이나 콜레이션을 적용하는 방법

문자 집합이나 콜레이션은 DB 수준에서 설정할 수도 있고, 테이블 수준으로 설정할 수도 있고, 칼럼 수준으로 설정할 수 있음

<br>

- tb_member 테이블을 생성하면서 member_id 칼럼의 콜레이션을 latin1_general_cs로 설정

    그래서 member_id 칼럼은 숫자나 영문 알파벳, 키보드의 특수 문자 위주로만 저장할 수 있고, _cs 계열의 콜레이션이므로 대소문자 구분을 하는 정렬이나 비교를 수행

    -> 그러면 id 컬럼을 만들 때는 latin1_general_cs가 더 좋을 듯

- member_name 칼럼은 콜레이션이 utf8_bin으로 설정됐으므로 한글이나 다른 나라의 언어를 사용할 수 있지만 _bin이 사용됐으므로 대소문자를 구분하는 정렬과 비교를 수행

- member_email 칼럼은 아무런 문자 집합이나 콜레이션을 정의하지 않았으므로 DEFAULT 설정

<br>





대표적으로 latin 계열의 문자 집합에 대해서 _ci, _cs, _bin 콜레이션의 정렬 규칙을 테스트해 보기 위해 tb_collate 테이블에 여러 종류의 콜레이션을 섞어서 테이블을 생성

<p align="center"><img src="./images/15_12.png" width="50%"></p>

<p align="center"><img src="./images/15_13.png" width="90%"></p>

<br>

<p align="center"><img src="./images/15_14.png" width="90%"></p>

<br>

<p align="center"><img src="./images/15_15.png" width="90%"></p>

<br>

<p align="center"><img src="./images/15_16.png" width="90%"></p>

<br>

<p align="center"><img src="./images/15_17.png" width="90%"></p>

<br>

첫번째 예제는 latin1_general_ci 콜레이션으로 정렬한 예제로 출력된 순서가 a와 A 중 소문자가 먼저인 것처럼 보이지만 대소문자 구분이 없이 정렬

두번째 예제는 latin1_general_cs 콜레이션으로 정렬한 예제로 출력된 순서가 대문자가 소문자보다 먼저 정렬

세번째 예제는 latin1_bin 콜레이션으로 정렬한 예제로 대문자만 먼저 정렬되고 그 다음에 소문자가 정렬

네번째 예제는 조금 다른 성격의 정렬인데, 특수문자를 먼저 정렬하고 그다음에 알파벳으로 정렬

<br>

때로 WHERE 조건의 검색은 대소문자를 구분하지 않고 실행하되 정렬은 대소문자를 구분해서 해야 할 때도 있는데

이럴 때는 검색과 정렬 작업 중 하나는 인덱스를 이용하는 것을 포기할 수밖에 없음
 
Why? 콜레이션을 하나로 정해서 인덱스를 정렬할텐데 고를 수가 없기 때문

주로 이 때는 콜레이션을 _ci(대소문자 구분 X)로 만들어 검색은 인덱스를 충분히 이용할 수 있게 하고, 

정렬은 Using filesort 형태로 처리하는 것이 일반적

<br>

모두 인덱스를 이용하고 싶으면 정렬을 위한 콜레이션을 사용하는 칼럼을 하나 더 추가하고 검색은 원본 칼럼, 정렬은 복사된 칼럼을 이용하는 방법도 있으니

데이터의 양이나 업무의 중요도를 적절히 반영해 방법을 선택

<br>

<p align="center"><img src="./images/15_18.png" width="90%"></p>

<br>

각 칼럼의 문자 집합이나 콜레이션을 정확히 확인하려면 information_schema DB의 columns 뷰를 확인해보면 됨

### utf8mb4 문자 집합의 콜레이션

실제 응용 프로그램에서는 latin 계열 문자 집합은 아주 특별한 경우 이외에는 거의 사용되지 않음

최근에는 응용 프로그램의 다국어 지원이 필수적이어서 대부분 utf8mb4 문자 집합을 사용할 것

<p align="center"><img src="./images/15_19.png" width="90%"></p>

<br>

다음 4개의 콜레이션은 utf8(utf8mb3) or utf8mb4 문자 집합의 콜레이션 중 하나

콜레이션 이름의 숫자 값은 콜레이션의 비교 알고리즘 버전

별도 숫자 값이 명시돼 있지 않은 콜레이션은 UCA 버전 4.0.0을 의미

<p align="center"><img src="./images/15_20.png" width="90%"></p>

<br>

콜레이션 이름에 로캘(Locale)이 포함돼 있는지 여부로 언어에 종속적인 콜레이션과 비종속적인 콜레이션으로 구분

utf8mb4_0900_ai_ci와 같이 언어 비종속적인 콜레이션은 문자 셋의 기본 정렬 순서에 의해 정렬 및 비교가 수행

언어 종속적인 콜레이션은 해당 언어에서 정의한 정렬 순서에 의해 정렬 및 비교가 수행

<br>

UCA 9.0.0 버전은 그 이전 버전의 콜레이션보다 빠르다고 MySQL 매뉴얼에서 소개되고 있음

하지만 간단한 테스트만 해봐도 그렇지 않다는 것을 확인할 수 있었음

9.0.0 버전은 모두 NO PAD 옵션으로 문자열 비교 작업이 처리되기 때문에 더 빠르게 작동한다고 소개돼 있지만 크게 성능 영향은 없는 것으로 보임

<p align="center"><img src="./images/15_21.png" width="60%"></p>

<br>

다음 테스트 결과를 보면 오히려 일반적으로 많이 사용되는 2개의 콜레이션 기준으로 볼 때 이전 버전이 더 빠른 것을 확인 가능

위의 테스트 결과를 보고 단순히 성능 때문에 utf8mb4_general_ci 콜레이션을 선택하지는 말자

비교 횟수가 많아서 큰 차이를 보이는 것 같지만 실제로는 문자열 비교 한 번에 대략 0.1 마이크로 차이니까 콜레이션의 필요에 따라 결정해야 할 부분이지 성능을 기준으로 콜레이션을 선택하지는 않도록 하자

<br>

`utf8mb4_0900 콜레이션은 NO PAD 옵션으로 인해 문자열 뒤에 존재하는 공백도 유효 문자로 취급되어 비교되고, 이로 인해 기존과는 다른 비교 결과를 보일 수도 있으므로 주의`

<p align="center"><img src="./images/15_22.png" width="80%"></p>

<p align="center"><img src="./images/15_23.png" width="80%"></p>

<br>

이렇게 기본 콜레이션이 변경되면 5.7 버전부터 존재하던 테이블은 이미 utf8mb4_general_ci 콜레이션을 사용하고 있기 떄문에 이 두 테이블을 조인할 때 에러가 발생하거나 성능이 심각하게 떨어짐

이러한 문제를 해결할 수 있게 MySQL 서버는 default_collation_for_utf8mb4 시스템 변수를 제공

default_collation_for_utf8mb4 시스템 변수에 utf8mb4_general_ci를 설정하면 문자 집합이 utf8mb4로 설정될 경우 콜레이션들도 utf8mb4_general_ci로 초기화

하지만 default_collation_for_utf8mb4 시스템 변수는 일시적으로 제공되는 기능이므로 영구적으로 사용하기엔 불안

<br>

당분간 utf8mb4_0900_ai_ci로 콜레이션을 변경할 예정이 없다면 MySQL 서버의 설정 파일(my.cnf)에 콜레이션 관련 시스템 변수를 utf8mb4_general_ci로 고정해두는 것이 좋음

