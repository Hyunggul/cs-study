# 10장. HTTP/2.0

<br>

## 10.1 HTTP/2.0의 등장 배경

- HTTP/1.1 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되었다.

- 커넥션 하나를 통해 요청 하나를 보내고 그에 대해 응답 하나만을 받는 HTTP의 메시지 교환 방식은 단순하였지만 응답을 받아야만 그다음 요청을 보낼 수 있기 때문에 lactency를 피할 수 없다.

- 이 문제를 회피하기 위해 병렬 커넥션이나 파이프라인 커넥션이 도입되었지만 근본적인 해결책은 아니었다.

- 회전 지연을 줄이기 위해 새로운 프로토콜을 제안하기 시작하였다.

    1. WAKA
    2. Microsoft S+M (Speed + Mobility)
    3. SPDY (2.0의 기반)

- SPDY의 특징

    - 헤더 압축 → 대역폭 절약
    - 1 TCP 다중 커넥션 (회전지연 줄임)
    - 서버 푸시

<br>

## 10.2 개요

- HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다. 이때 커넥션을 초기화하는 것은 클라이언트이다.

- HTTP/2.0 요청과 응답은 한 개 이상의 프레임에 담기며, HTTP 헤더는 압축되어 담긴다.

<br>

### 프레임

- 모든 메시지는 프레임에 담겨 전송된다.

- 프레임들에 담긴 요청과 응답은 스트림을 통해 보내진다.

<br>

### 스트림

- 한 개의 스트림이 한 쌍의 요청과 응답을 처리한다.

- 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있으므로, 여러 개의 요청과 응답을 동시에 처리하는 것이 가능하다.

- 스트림은 우선순위도 가질 수 있다.

- 스트림을 상대방과 협상없이 일방적으로 만든다. TCP 패킷을 주고 받는 시간을 낭비하지 않아도 된다.

<br>

### 헤더 압축

- 요즘의 웹페이지는 수십, 수백 번의 요청을 보내기 때문에 헤더의 크기가 영향을 끼칠 수 있다. 그래서 HTTP/2.0에서는 HTTP 메시지의 헤더를 압축하여 전송한다.

<br>

### 서버 푸시

- 어떤 HTML 파일을 요청할 때 서버에서 이 파일이 링크하고 있는 CSS, JS, 이미지 등을 클라이언트에서 요청하기 전에 같이 반환 해줄 수 있다.

<br>

## 보안 이슈

<br>

### 중개자 캡슐화 공격

- 2.0 메시지를 프록시가 1.1 메시지로 변환할 때 의미 변질 가능성이 있다.

- 2.0 메시지는 헤더 필드의 이름과 값을 바이너리로 인코딩되기에 어떤 문자열이든 헤더 필드로 작성할 수 있다.(줄바꿈 문자열까지도)

- 그래서 정상적인 2.0 요청/응답을 불법적인 1.1 메시지로 번역되게 할 수 있다.
  
- 반대로 1.1 메시지는 이를 허용하지 않으므로 2.0 메세지로 번역하는 과정에서는 이런 문제가 발생하지 않는다.

<br>

### 긴 커넥션 유지로 인한 개인정보 누출 우려

- 일반적으로, 한 커넥션이 스트림 식별자가 고갈되거나 한 쪽에서 강제로 끊기 전에는 계속 유지된다. 이 때문에 (길게 계속 유지되는 경우) 보안 문제가 발생할 수 있다.
