# 12장 기본 인증

* 웹사이트에 개인이 작성한 문서 등은 해당 소유자의 동의 없이는, 권한이 없는 사용자는 볼 수 없어야 한다. 그러기 위해서는 서버가 사용자가 누구인지 식별할 수 있어야 한다.
* 서버가 사용자 식별을 할 수 있으면, 그 사용자가 어떤 작업이나 리소스에 접근할 수 있는지 결정할 수 있다.
* 인증은 당신이 누구인지 증명하는 것이다.
    - 보통 사용자 이름과 비밀번호를 입력해서 인증한다.
    - HTTP는 자체적인 인증 관련 기능을 제공한다.

## 12.1 인증

* 인증은 여권이나 신분증처럼 누구인지 증명해 보이는 것이다.

* 완벽한 인증은 없지만, 여러 데이터는 당신이 누구인지 판단하는데 도움이 된다.

### 12.1.1 HTTP의 인증요구 / 응답 프레임워크

* HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구 / 응답 프레임워크를 제공한다.

* 그림 12-1 : HTTP 인증 모델

    <img src = images/12/example_01.png>
    
    <br>

    1. 웹 애플리케이션이 HTTP 요청 메시지를 받으면, 서버는 요청을 처리하는 대신에 개인 정보를 요구하는 인증 요구로 응답할 수 있다.
    
    2. 사용자가 다시 요청을 보낼 때는 인증 정보를 첨부해야 한다.

    * 만약 인증 정보가 맞지 않으면 서버는 클라이언트에 다시 인증 요구를 보내거나 에러를 낼 수 있다.
    * 인증 정보가 맞으면 요청은 문제없이 처리가 완료된다.

### 12.1.2 인증 프로토콜과 헤더

* HTTP는 필요에 따라 고쳐 쓸 수 있는 제어 헤더를 통해, 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제공한다.

* 표 12-1 에 나열된 헤더의 형식과 내용은 인증 프로토콜에 따라 달라진다.

    * 표 12-1 : 네 가지 인증 단계

    단계|헤더|설명|메서드 / 상태
    |---|---|---|---|
    요청||첫 번째 요청에는 인증 정보가 없다.|GET
    인증요구|WWW-Authenticate|서버는 사용자에게 사용자 이름과 비밀번호를 제공하라는 지시의 의미로 401 상태 정보와 함께 요청을 반려한다. 서버에는 각각 다른 비밀번호가 있는 영역들이 있을 것이므로, 서버는 WWW-Authenticate 헤더에 해당 영역을 설명해 놓는다.| 401 Unauthorized
    인증|Authorization|클라이언트는 요청을 다시 보내는데, 이번에는 인증 알고리즘과 사용자 이름과 비밀번호를 기술한 Authorization 헤더를 함께 보낸다.|GET
    성공|Authenticate-Info|인증 정보가 정확하면, 서버는 문서와 함께 응답한다. 어떤 인증 알고리즘은 선택적인 헤더인 Authenticate-Info에 인증 세션에 관한 추가 정보를 기술해서 응답하기도 한다.| 200 OK

<br><br>

* 그림 12-2 : 기본 인증의 예

    <img src = images/12/example_02.png>

    <br>

    1. 서버가 사용자에게 인증요구를 보낼 때, 서버는 401 Unauthorized 응답과 함께 WWW-Authenticate 헤더를 기술해서 어디서 어떻게 인증할지 설명한다.
    2. 클라이언트가 서버로 인증하려면. 인코딩된 비밀번호와 그 외 인증 파라미터들을 Authorization 헤더에 담아서 요청을 다시 보낸다.
    3. 인증 요청이 성공적으로 완료되면, 서버는 정상적인 상태 코드 (200 OK) 를 반환하며, 추가적인 인증 알고리즘에 대한 정보를 Authentication-Info 헤더에 기술 할 수도 있다.



### 12.1.3 보안 영역

* 웹 서버는 기밀문서를 보안 영역(realm) 그룹으로 나눈다.

* 보안 영역은 저마다 다른 사용자 권한을 요구한다.

* realm 파라미터가 함께 기술된 기본 인증의 예
    ```
    HTTP/1.0 401 Unatuthorized
    WWW-Authenticate: Basic realm="Corporate Financials"
    ```

    * realm은 "Corporate Financials(회사 재무) 같이 해설 형식으로 돼 있어서, 사용자가 권한의 범위를 이해하는 데 도움이 되어야 한다.

* realm에 "executive-committee@bigcompany.com" 같은 서버의 호소트명을 넣는 것도 유용할 수 있다.

* 그림 12-3 웹 서버의 보안 영역
    <img src = images/12/example_03.png>

<br><br>


## 12.2 기본 인증

* 기본 인증은 가장 잘 알려진 HTTP 인증 규약이다.

* 거의 모든 주요 클라이언트와 서버에 기본 인증이 구현되어 있다.

* 기본 인증에서, 웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비밀번호를 요구할 수 있다.

    - 서버는 200 대신 401 상태 코드와 함께, 클라이언트가 접근하려고 했던 보안 영역을 WWW-Authenticate에 기술해서 응답하여 인증요구를 시작한다.

    - 인증 정보를 포함하여 요청하려는 응답을 받은 브라우저는, 사용자에게 계정과 비밀번호를 입력할 수 있는 대화상자를 연다.

    - 여기서 계정과 비밀번호는 사용자가 해당 영역에 접근 권한이 있는지 검사하는데 사용한다.

    - 브라우저는 사용자가 입력한 사용자 이름과 비밀번호를 Authorization 요청 헤더 안에 암호화해서 서버로 다시 보낸다.


### 12.2.1 기본 인증의 예

* 그림 12-2
    <img src = images/12/example_02.png>

    <br>

    1. 사용자가 자신의 가족사진인 /family/jeff.jpg를 요청한다.
    2. 서버는 WWW-Authenticate 헤더와 함께 개인 가족사진에 접근하는 데 필요한 비밀번호를 요구하는 401 Authorization Required 응답을 반환한다.
    3. 브라우저가 401 응답을 받고 Family 영역에 관한 사용자 이름과 비밀번호를 요구하는 대화상자를 띄운다.  
    사용자가 사용자 이름과 비밀번호를 입력하면, 브라우저는 그것들을 콜론으로 이어 붙이고, base-64 방식으로 인코딩하고, Authorization 헤더에 그 값을 담아 서버로 다시 보낸다.
    4. 서버가 사용자 이름과 비밀번호를 디코딩하고, 그 값이 정확한지 검사한 후, 문제가 없으면 HTTP 200 OK 메시지와 함께 요청받았던 문서를 보낸다.

* HTTP 기본 인증의 WWW-Authenticate 헤더와 Authorization 헤더

    * 인증요구(서버에서 클라이언트로)
        - 각 사이트는 보안 영역마다 다른 비밀번호가 있을 것이다. realm은 요청 받은 문서 집합의 이름을 따옴표로 감싼 것으로, 사용자는 이 정보를 보고 어떤   비밀번호를 사용해야 하는지 알 수 있다.

        - ```
            WWW-Authenticate: Basic realm=따옴표로 감싼 문서 집합 정보
            ```
    
    * 응답(클라이언트에서 서버로)
        - 사용자 이름과 비밀번호는 콜론으로 잇고, base-64로 인코딩해서 사용자 이름과 비밀번호에 쉽게 국제문자를 포함할 수 있게 하고, 네트워크 트래픽에 사용자 이름과 비밀번호가 노출되지 않게 한다.

        - ```
            Authorization: Basic base-64로 인코딩한 사용자 이름과 비밀번호
            ```

* 기본 인증 프로토콜은 Authentication-Info 헤더를 사용하지 않는다.

### 12.2.2 Base-64 사용자 이름 / 비밀번호 인코딩

* HTTP 기본 인증은 사용자 이름과 비밀번호를 콜론으로 이어서 합치고, base-64 인코딩 메서드를 사용해 인코딩 한다.

* base-64 인코딩은 8비트 바이트로 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환한다.
    - 각 6비트 조각은 대부분 문자와 숫자로 이루어진 특별한 64개의 문자 중에서 선택된다.

* 그림 12-4 : base-64 인코딩의 예시
    <img src = images/12/example_04.png>

<br>

* Base-64 인코딩은 바이너리, 텍스트, 국제 문자 데이터 문자열을 받아서 전송할 수 있게, 그 문자열을 전송 가능한 문자인 알파벳을 변환하기 위해 발명됐다.

* 전송 중에 원본 문자열이 변질될 걱정 없이 원격에서 디코딩할 수 있다.

* base-64 인코딩은 국제 문자나 HTTP 헤더에서 사용할 수 없는 문자를 포함한 사용자 이름이나 비밀번호를 보내야 할 때 유용할 수 있다.

* base-64는 어렵지 않게 사용자 이름과 비밀번호 문자를 섞을 수 있기 때문에, 서버나 네트워크를 관리하면서 뜻하지 않게 사용자 이름과 비밀번호를 노출되는 문제를 예방하는 데 도움을 준다.

### 12.2.3 프락시 인증

* 중개 프락시 서버를 통해 인증할 수도 있다.
    - 어떤 회사는 사용자들이 회사의 서버나 LAN이나 무선 네트워크에 접근하기 전에 프락시 서버를 거치게 하여 사용자를 인증한다.

* 프락시 서버에서 접근 정책을 중앙 관리 할 수 있기 때문에, 회사 리소스 전체에 대해 통합적인 접근 제어를 하기 위해서 프락시 서버를 사용하면 좋다.

* 이 절차의 첫 번째 단게는 프락시 인증으로 사용자를 식별하는 것이다.

* 프락시 인증은 웹 서버의 인증과 헤더와 상태 코드만 다르고 절차는 같다.

* 표 12-3 : 웹 서버 인증 vs 프락시 인증
    웹 서버 | 프락시 서버
    ---|---
    비인증 상태 코드 : 401 | 비인증 상태 코드 : 407
    WWW-Authenicate | Proxy-Authenicate
    Authorization | Proxy-Authorization
    Authenticataion-Info |Proxy-Authenticataion-Info

<br>

## 12.3 기본 인증의 결함

* 기본 인증은 단순하고 편리하지만 안심할 수 없다.

* 기본 인증은 악의적이지 않은 누군가가 의도치 않게 리소스에 접근하는 것을 막는데 사용하거나, SSL 같은 암호 기술과 혼용한다.

* 기본 인증은 일반적인 환경에서 개인화나 접근을 제어하는데 편리하며, 다른 사람들이 보지 않기를 원하기는 하지만, 보더라도 치명적이지 않은 경우에는 유용하다.

