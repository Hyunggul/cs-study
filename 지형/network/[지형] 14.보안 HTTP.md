# 14장 보안 HTTP

* 이전 기본 인증과, 다이제스트 인증은 중요한 트랜잭션을 보호하기에는 부족하다.

* 이 장에서는 디지털 암호화를 이용해 도청이나 위조로부터 HTTP 트랜잭션을 안전하게 보호하는 더 복잡하고 적극적인 기술을 제시한다.

## 14.1 HTTP를 안전하게 만들기

* 우리는 밑에 표의 내용을 제공해 줄 수 있는 HTTP 보안 기술이 필요하다.

    필요 기술| 내용
    |---|---|
    서버인증|클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알 수 있어야 한다.
    클라이언트 인증|서버는 자신이 가짜가 아닌 진짜 사용자와 이야기하고 있음을 알 수 있어야 한다.
    무결성|클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
    암호화|클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다.
    효율|저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.
    편재성(Ubiquity)|프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
    관리상 확장성|누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
    적응성|현재 알려진 최선의 보안 방법을 지원해야 한다.
    사회적 생존성|사회적 문화적, 정치적 요구를 만족시켜야 한다.


### 14.1.1 HTTPS

* `HTTPS`는 HTTP를 안전하게 만드는 방식 중 가장 인기 있는 것이다.
    - 넷스케이프에서 개척하였으며, 모든 주류 브라우저와 서버에서 지원한다.

* 웹페이지에 HTTP가 아닌 HTTPS로 접근하고 있는 경우, URL이 **https://** 로 시작하는 것을 알 수 있다.
    - 몇몇 브라우저는 보안 아이콘을 보여주기도 한다.

* HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다.

* HTTPS는 HTTP의 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작하는데,  
이 보안 계층은 `안전 소켓 계층(Secure Sockets Layer, SSL)` 혹은 `전송 계층 보안(Transport Layer Security, TLS)`을 이용하여 구현된다.

* 어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에,  
보안 HTTP를 사용하기 위해 웹 클라이언트와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요는 없다.

* 대부분의 경우, TCP 입력 / 출력 호출을 SSL 호출로 대체하고, 보안 정보를 설정하고 관리하기 위한 몇 가지 호출을 추가하기만 하면 된다.

* 그림 14-2 : HTTP와 HTTPS 게층

<img src = images/14/example_01.png>

## 14.2 디지털 암호학

* SSL과 HTTPS에서 이용되는 암호 인코딩 기법에 대해 약간의 배경 지식을 제공할 필요가 있다.

* 이 장에서는 다음과 같은 내용에 대해 이야기할 것이다.

    디지털 암호의 기초|내용
    |---|---|
    암호|텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
    키|암호의 동작을 변경하는 숫자로 된 매개변수
    대칭키 암호 체계|인코딩과 디코딩에 같은 키를 사용하는 알고리즘
    비대칭키 암호 체계|인코딩과 디코딩에 다른 키를 사용하는 알고리즘
    공개키 암호법|비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
    디지털 서명|메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
    디지털 인증서|신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

### 14.2.1 비밀 코드의 기술과 과학

* 암호법(cryptography)은 메시지 인코딩과 디코딩에 대한 과학이자 기술(art)이다.

* 암호법은 단순히 메시지를 암호화하는 것뿐 아니라, 메시지의 변조를 방지하기 위해 사용하고, 어떤 메시지나 트랜잭션의 저자임을 증명하는 데도 사용될 수 있다.

### 14.2.2 암호(cipher)

* 암호법은 암호라 불리는 비밀 코드에 기반한다.

* 암호
    - 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법이다.

* 평문, 텍스트
    - 인코딩되기 전의 원본 메시지

* 암호가 적용되어 코딩된 메시지는 보통 암호문이라고 불린다.

* 그림 14-3 : 평문과 암호문

<img src = images/14/example_02.png>

<br>

* 그림 14-4 : Rotate-by-3 암호의 예

<img src = images/14/example_03.png>

### 14.2.4 키가 있는 암호

* 암호의 유출로 인해 대부분의 기계들에는 암호의 동작방식을 변경할 수 있는 다이얼이 달려있다.

* 다이얼, 이러한 암호 매개변수를 `키`라고 부른다.

* 오늘날 대부분의 암호 알고리즘은 키를 사용한다.

* 그림 14-5 : 다른 키를 사용하는 N번-회전 암호

<img src = images/14/example_04.png>

### 14.2.5 디지털 암호

* 디지털 게산의 도래로, 두 가지 주요한 발전이 있었다.
    1. 기계가 갖는 속도 및 기능에 한계에서 벗어나, 복잡한 인코딩과 디코딩 알고리즘이 가능해졌다.
    2. 매우 큰 키를 지원하는 것이 가능해져서 많은 가상 암호 알고리즘을 만들어낼 수 있게 되었다.

* 알고리즘은 데이터 덩어리를 받아서 알고리즘과 키의 값에 근거하여 인코딩하거나 디코딩하는 함수이다.

* 그림 14-6 : 인코딩

<img src = images/14/example_05.png>

<br>

* 그림 14-7 : 디코딩

<img src = images/14/example_06.png>

## 14.3 대칭키 암호법

* 대칭키 암호법은 인코딩과 디코딩에 같은 키를 사용하는 알고리즘이다.

* 대표적인 대칭키 암호 알고리즘으로는 DES, Triple-DES, RC2, RC4가 있다.

### 14.3.1 키 길이와 열거 공격(Enumeration Attack)

* 비밀 키가 누설되면 안된다는 것은 매우 중요하다.

* 인코딩 및 디코딩 알고리즘은 공개적으로 알려져 있으므로, 키만이 유일한 비밀이다.

* 무차별로 모든 키 값을 대입해보는 공격을 `열거 공격`이라고 한다. 

* 열거 공격에 있어서 가능한 키 값의 개수는 키가 몇 비트이며 얼마나 많은 키가 유효한지에 달려 있다.

    - 40비트 키라면 $2^{40}$(약 1조) 가지가 가능하고, 56비트, 64비트, 80비트, 128비트 키에 따라 개수는 증가한다.

    - 공격 비용과 시간을 고려했을 때, 긴 키를 사용하는 암호문은 열거 공격의 가능성을 차단할 수 있다.

### 14.3.2 공유키 발급하기

* 대칭키 암호의 단점 중 하나는 발송자와 수신자가 서로 대화하려면 둘 다 `공유키`를 가져야 한다는 것이다.

* 만약 $N$ 개의 노드가 있고, 각 노드가 상대 $N-1$ 과 은밀하게 대화를 나누어야 한다면, 대략 총 $N^{2}$ 개의 비밀 키가 필요하다.
    - 관리해야 하는 사람 입장에서 이것은 지옥이다.

## 14.4 공개키 암호법

* 한 쌍의 호스트가 하나의 인코딩 / 디코딩 키를 사용하는 대신, 공개키 암호 방식은 두 개의 비대칭 키를 사용한다.

    1. 호스트의 메시지를 인코딩하기 위한 것
    2. 그 호스트의 메시지를 디코딩하기 위한 것

    - 인코딩 키는 모두를 위해 공개되어 있다. (공개키 암호 방식)

    - 호스트만이 개인 디코딩 키를 알고 있다.

* 그림 14-8 : 공개키 암호는 인코딩과 디코딩에 사용하는 비대칭이다.

<img src = images/14/example_07.png>

<br>

* 그림 14-9 : 공개키 암호 방식은 호스트마다 한 개의 공개키를 할당한다.

<img src = images/14/example_08.png>

<br>

* 키의 분리는, 메시지의 인코딩은 누구나 할 수 있도록 해주는 동시에, 메시지를 디코딩하는 능력은 소유자에게만 부여한다.

### 14.4.1 RSA

* 공개키 비대칭 암호의 과제는, 설혹 악당이 아래 내용을 알고 있다 해도 비밀인 개인 키를 계산할 수 없다는 것을 확신시켜 주는 것이다.

* 공개키, 가로채서 얻은 암호문의 일부(네트워크 스누핑), 메시지와 그것을 암호화한 암호문

* 위 모든 요구를 만족하는 공개키 암호 체계 중 유명한 하나는 RSA 알고리즘이다.


### 14.4.2 혼성 암호 체계와 세션 키

* 비대칭 공개키 암호 방식은 누구나 공개키만 알면 그 키에 대응되는 공개 서버에 안전하게 메시지를 보낼 수 있게 해주므로 훌륭하다.

* 두 노드가 안전하게 의사소통을 하려고 할 때 개인 키에 대한 협상을 먼저 해야 할 필요가 없다.

* 그러나 공개키 암호 방식의 알고리즘은 느린 경향이 있다.

* 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰인다.
    - 노들들 사이의 안전한 의사소통 채널을 수립할 때는 편리하게 공개 키 암호를 사용한다.
    - 이렇게 만들어진 안전한 채널을 통해 임시의 무작위 대칭 키를 생성하고 교환한다.
    - 이 후의 나머지 데이터를 암호화할 때는 빠른 대칭 키를 사용하는 방식이 흔히 쓰인다.

## 14.5 디지털 서명

* 암호 체계는 메시지를 암호화하고 해독하는 것뿐 아니라, 누가 메시지를 썼는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명을 하는 데에 이용될 수 있다.

### 14.5.1 서명은 암호 체크섬이다.

* 디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬이다.

* 이들은 두 가지 이점을 가진다.
    1. 서명은 메시지를 작정한 저자가 누군지 알려준다.
        - 저자는 저자의 극비 개인 키를 갖고 있기 떄문에, 오직 저자만이 이 체크섬을 계산할 수 있다.
        
        - 체크섬은 저자의 개인 '서명'처럼 동작한다.
    
    2. 서명은 메시지 위조를 방지한다.
        - 만약 악의적인 공격자가 송신 중인 메시지를 수정했다면, 체크섬은 더 이상 그 메시지와 맞지 않게 될 것이다.
        
        - 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에, 침입자는 그 위조된 메시지에 대한 올바른 체크섬을 날조해낼 수 없을 것이다.

* 디지털 서명은 보통 비대칭 공개키에 의해 생성된다.

* 개인 키는 오직 소유자만이 알고 있기 때문에, 저자의 개인 키는 일종의 '지문'처럼 사용된다.

* 그림 14-10 : 해독된 디지털 서명

<img src = images/14/example_09.png>

## 14.6 디지털 인증서

* 디지털 인증서는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있다.

* 디지털 인증서는 더 위조하기 어렵고, 본질적으로 더 높은 수준의 신뢰를 받게 된다.

### 14.6.1 인증서의 내부

* 디지털 인증서에는 또한 공식적으로 '인증 기관'에 의해 디지털 서명된 정보의 집합이 담겨있다.

* 기본적인 디지털 인증서는 보통 다음과 같이 인쇄된 ID에도 흔히 들어가게 되는 기본적인 것들을 담고 있다.
    
    - 대상의 이름 (사람, 서버, 조직 등)
    
    - 유효 기간

    - 인증서 발급자 (누가 이 인증서를 보증하는가)

    - 인증서 발급자의 디지털 서명

* 추가적으로, 디지털 인증서는 대상과 사용된 서명 알고리즘에 대한 서술적인 정보뿐 아니라 보통 대상의 공개키도 담고 있다.

* 그림 14-11 : 일반적인 인증서의 구조

<img src = images/14/example_10.png>

### 14.6.2 X.509 v3 인증서

* 오늘날 사용되는 대부분의 인증서가 그들의 정보를 X.509라 불리는 표준화된 서식에 저장하고 있다.

* X.509 v3 인증서는 인증 정보를 파싱 하근ㅇ한 필드에 넣어 구조화하는 표준화된 방법을 제공한다.

* X.509 인증 필드
    - 버전
    - 일련번호
    - 서명 알고리즘 ID
    - 인증서 발급자
    - 유효 기간
    - 대상의 이름
    - 대상의 공개 키 정보
    - 발급자의 고유 ID (선택적)
    - 대상의 고유 ID (선택적)
    - 확장
    - 인증기관 서명

### 14.6.3 서버 인증을 위해 인증서 사용하기

* 사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다.

* 만약 서버가 인증서를 갖고 있지 않다면, 보안 커넥션은 실패한다.

* 서버 인증서는 다음을 포함한 많은 필드를 갖고 있다.
    - 웹 사이트의 이름과 호스트 명
    - 웹 사이트의 공개키
    - 서명 기관의 이름
    - 서명 기관의 서명

* 그림 14-12 : 인증서의 디지털 서명을 이용해 어떻게 그 인증서의 무결성을 검증하는지 보여준다.

<img src = images/14/example_11.png>

## 14.7 HTTPS의 세부사항

* HTTPS는 HTTP의 가장 유명한 보안 버전이다.

* 널리 구현되었으며 주류 상용 브라우저와 서버에 구현되어 있다.

* HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다.

* 이 기법들의 집합은 글로벌 인터넷 환경에서도 HTTPS를 매우 안전한 동시에 매우 유연하고 관리하고 쉽게 만들어 준다.

### 14.7.1 HTTPS 개요

* HTTPS는 그냥 보안 전송 계층을 통해 전송되는 HTTP이다.

* 그림 14-13 : HTTP 전송 단계에서의 보안

<img src = images/14/example_12.png>  

<br>

1. 암호화되지 않은 HTTP 메시지를 TCP를 통해 전 세계의 인터넷 곳곳으로 보낸다.

2. HTTPS는 HTTP 메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안계층으로 보낸다.

* 오늘날, HTTPS의 보안 계층은, SSL과 TLS로 구현되었다.

### 14.7.2 HTTPS 스킴

* 보안 HTTP는 선택적이다.
    - 따라서 웹 서버로의 요청을 만들 때, 웹 서버에게 HTTP의 보안 프로토콜 버전을 수행한다고 말해줄 방법이 필요하다.

* URL 스킴
    - 보안이 없는 일반적인 HTTP URL의 스킴 접두사
    ```
    http://www.joes-hardware.com/index.html
    ```

    - 보안이 되는 HTTPS 프로토콜에서 URL의 스킴 접두사
    ```
    https://www.joes-hardware.com/index.html
    ```

* 클라이언트는 웹 리소스에 대한 트랜잭션 수행을 요청받으면 URL의 스킴을 검사한다.

* 그림 14-14 : HTTP와 HTTPS 포트번호

    <img src = images/14/example_13.png>

    <br>

    * 만약 URL이 http 스킴을 갖고 있다며느, 클라이언트는 서버에 80번(기본값) 포트로 연결하고 평범한 HTTP 명령을 전송한다.

    * 만약 URL이 https 스킴을 갖고 있다면, 클라이언트는 서버에 443번(기본값) 포트로 연결하고  
    서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하면서 '핸드셰이크'를 하고, 암호화된 HTTP 명령이 뒤를 잇는다.


### 14.7.3 보안 전송 셋업

* 그림 14-15 : HTTP와 HTTPS 트랜잭션

    <img src = images/14/example_14.png>

    * HTTPS에서의 절차는 SSL 보안 계층 때문에 HTTP의 절차 보다 약간 더 복잡하다.
        
        1. 클라이언트는 먼저 웹 서버의 443 포트로 연결한다.

        2. TCP 연결이 되고나면, 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화한다.

        3. 핸드셰이크가 완료되면 SSL 초기화는 완료되며, 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있다.

        4. 이 메시지는 TCP로 보내지기 전에 암호화된다.


### 14.7.4 SSL 핸드셰이크

* 암호화된 HTTP 메시지를 보낼 수 있게 되기 전에, 클라이언트와 서버는 SSL 핸드셰이크를 할 필요가 있다.

* 핸드셰이크에서는 다음과 같은 일이 일어난다.
    - 프로토콜 버전 번호 교환

    - 양쪽이 알고 있는 암호 선택

    - 양쪽의 신원을 인증

    - 채널을 함호화하기 위한 임시 세션 키 생성

* 암호화된 HTTP 데이터가 네트워크를 오가기도 전에, SSL은 통신을 시작하기 위해 상당한 양의 핸드셰이크 데이터를 주고받는다.

* 그림 14-16 : SSL 핸드셰이크

<img src = images/14/example_15.png>

### 14.7.5 서버 인증서

* SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 상호 인증을 지원한다.
    
    - 그러나 오늘날, 클라이언트 인증서는 웹 브라우징에선 흔히 쓰이지 않는다.

    - 대부분의 사용자는 개인 클라이언트 인증서를 갖고 있지도 않다.

* 한편, 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다.

* 인증서는 서버에 그의 신용카드나 개인 정보를 보내기 전에 그 서버를 얼마나 신뢰할 수 있는지 평가하는 것을 도와줄 것이다.

* 서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름, 그리고 그외의 정보를 보여주는 X.509 v3 에서 파생된 인증서이다.

* 그림 14-17 :  X.509 인증서

<img src = images/14/example_16.png>

### 14.7.6 사이트 인증서 검사

* 넷스케이프가 제안한 웹 서버 인증서 검사를 위한 한 알고리즘은 대부분의 웹브라우저의 검사 기법의 기초를 구축했다.

* 이 알고리즘의 수행 단계는 다음과 같다.

1. 날짜 검사

    - 먼저, 브라우저는 인증서가 여전히 유효함을 확인하기 위해 인증서의 시작 및 종료일을 검사한다.

    - 만약 인증서가 만료되었거나 아직 활성화되지 않았다면, 인증서 검사는 실패하고 브라우저는 에러를 보여준다.

2. 서명자 신뢰도 검사

    - 모든 인증서는 서버를 보증하는 어떤 인증 기관(Certificate Authority, CA)에 의해 서명되어 있다.

    - 여러 가지 수준의 인증서가 있는데, 각각은 다른 수준의 배경 검증을 요구한다.

3. 서명 검사

    - 한번 서명 기관이 믿을 만하다고 판단하면, 브라우저는 서명기관의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄으로써 인증서의 무결성을 검사한다.

4. 사이트 신원 검사

    - 서버가 누군가 다른 이의 인증서를 복사하거나 그들의 트래픽을 가로채는 것을 방지하기 위해,  
    대부분의 브라우저는 인증서의 도메인 이름이 대화 중인 서버의 도메인 이름과 비교하여 맞는지 검사한다.

    - 서버 인증서에는 보통 단일 도메인 이름이 들어있지만  
    몇몇 CA는 서버 클러스터나 서버 팜을 위해 서버 이름의 목록이나 서버 이름들에 대한 와일드카드 표현이 들어있는 인증서를 만든다.

    - 만약 호스트 명이 인증서의 신원과 맞지 않는다면,  
    사용자를 우선으로 생각하는 클라이언트는 반드시 이 사실을 사용자에게 알리거나 잘못된 인증서 에러와 함께 커넥션을 끊어야 한다.


### 14.7.7 가상 호스팅과 인증서

* 가상 호스트(하나의 서버에 여러 호스트 명)로 운영되는 사이트의 보안 트래픽을 다루는 것은 까다로운 경우가 많다.

    - 몇몇 인기 있는 웹 서버 프로그램은 오직 하나의 인증서만을 지원한다.
    
    - 만약 사용자가 인증서의 이름과 정확히 맞지 않는 가상 호스트 명에 도착했다면 경고 상자가 나타날 것이다.

* 그림 14-18 : 서버 인증서에 나열된 공식 호스트명과 가상 호스트 명이 다를 경우

<img src = images/14/example_17.png>

<br>

* 이러한 문제를 피하기 위해, 브라우저의 소유자는 보안 트랜잭션을 시작하는 모든 사용자를 공식 호스트 명으로 리다이렉트 한다.

## 14.8 진짜 HTTPS 클라이언트

* SSL은 복잡한 바이너리 프로토콜이다.

* 몇 가지 SSL 클라이언트와 서버 프로그래밍을 쉽게 만들어주는 상용 혹은 오픈 소스 라이브러리들이 존재한다.

* OpenSSL은 SSL과 TLS의 가장 인기 있는 오픈 소스 구현이다.

## 14.9 프락시를 통한 보안 트래픽 터널링

* 클라이언트는 종종 그들을 대신하여 웹 서버에 접근해주는 웹 프락시 서버를 이용한다.

* 예를 들어, 많은 회사가 기업 네트워크와 공공 인터넷을 잇는 경계에 보안을 위한 프락시를 설치한다.

* 이 프락시는 방화벽 라우터가 HTTP 트래픽의 교환을 허락한 유일한 장치이며, 바이러스 검사나 기타 콘텐츠 제어를 수행할 것이다.

    * 그림 14-19 : 기업 방화벽 프락시
    
    <img src = images/14/example_18.png>
        
    <br>

* 그러나 클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화하기 시작했다면, 프락시는 더 이상 HTTP 헤더를 읽을 수 없다.

* 만약 프락시가 HTTP 헤더를 읽을 수 없다면, 프락시는 요청을 어디로 보내야 하는지 알 수 없게 된다.

    * 그림 14-20 : 프락시는 암호화된 요청을 다룰 수 없다.

    <img src = images/14/example_19.png>

    <br>


* HTTPS가 프락시와도 잘 동작할 수 있게 하기 위해, 클라이언트가 프락시에게 어디에 접속하려고 하는지 말해주는 방법을 약간 수정해야 한다.

* 인기 있는 기법 하나는 `HTTPS SSL 터널링 프로토콜`이다.

    - HTTPS 터널링 프로토콜을 사용해서, 클라이언트는 먼저 프락시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 말해준다.

    - 클라이언트는 이 내용을 프락시가 읽을 수 있도록 암호화가 시작되기 전의 평문으로 말해준다.

    - HTTP는 CONNECT라 불리는 새로운 확장 메서드를 이용해서 평문으로 된 종단 정보를 전송하기 위해 사용된다.

    - CONNECT 메서드는 프락시에게 희망하는 호스트와 포트번호로 연결을 해달라고 말해주며, 그것이 완료되면,  
    클라이언트와 서버 사이에서 데이터가 직접적으로 오갈 수 있게 해주는 터널을 만든다.

    - CONNECT 메서드는, 안전한 원 서버의 호스트 명과 포트를 콜로으로 구분된 형태로 제공하는, 한 줄로 된 텍스트 명령이다.

    - 이 호스트 : 포트에 뒤이어 스페이스 하나와 HTTP 버전 문자열과 CRLF가 순서대로 온다.

    - 0개 이상의 요청 헤더줄들이 이어진 다음, 빈 줄 하나가 온다. 

    - 빈 줄 다음에, 만약 커넥션을 수립하기 위한 핸드셰이크가 성공했다면, SSL 데이터 전송이 시작된다.

    ```
    CONNECT home.netscape.com:443 HTTP/1.0
    User-agent: Mozilla./1.1N
    
    <SSL로 암호화된 데이터가 이 다음에 온다...>
    ```

    - 요청의 빈 줄 다음에, 클라이언트는 프락시로부터의 응답을 기다릴 것이다.

    - 프락시는 요청을 평가하여 그것이 유효하고 사용자가 그러한 커넥션을 요청할 수 있도록 허가를 받았는지 확인한다.

    - 만약 모든 것이 적법하다면 프락시는 목적지 서버로 연결하고 성공하면 200 Connection Established 응답을 클라이언트에게 보낸다.

    ```
    HTTP/1.0 200 Connection established
    Proxy-agent: Netscape-Proxy/1.1
    ```
