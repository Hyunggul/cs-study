# 15장 엔터티와 인코딩

## 15.1 메시지는 컨테이너, 엔터티는 화물

* HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 생각한다면, `HTTP 엔터티`는 메시지의 실질적인 화물이다.

* 그림 15-1 : 간단한 엔터티

    <img src = images/15/example_01.png>

<br>

* 엔터티 헤더 필드

    * Content-Type
        - 엔터티에 의해 전달된 객체의 종류
    * Content-Length
        - 전달되는 메시지의 길이나 크기
    * Content-Language
        - 전달되는 객체와 가장 잘 대응되는 자연어
    * Content-Encoding
        - 객체 데이터에 대해 행해진 변형(압축 등)
    * Content-Location
        - 요청 시점을 기준으로, 객체의 또 다른 위치
    * Content-Range
        - 만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의한다.
    * Content-MD5
        - 엔터티 본문의 콘텐츠에 대한 체크섬
    * Last-Modified
        - 서버에서 이 콘텐츠가 생성 혹은 수정된 날
    * Expires
        - 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
    * Allow
        - 이 리소스에 대해 어떤 요청 메서드가 허용되는지
    * ETag
        - 이 인스턴스에 대한 고유한 검사기
    * Cache-Control
        - 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자
    
### 15.1.1 엔터티 본문

* 엔터티 본문은 가공되지 않은(날) 데이터만을 담고 있다.

* 다른 정보들은 모두 헤더에 담겨 있다.

* 엔터티 헤더는 날 데이터의 의미에 대해 설명할 필요가 있다.

* 엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작한다.

* 그림 15-2 : HTTP 메시지의 실례

    <img src = images/15/example_02.png>
    
    <br>

    - a : 텍스트 엔터티

    - b : 이미지 엔터티

    - 16진수 값들은 메시지의 내용을 알려준다.


## 15.2 Content-Length: 엔터티의 길이

* Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타낸다.

    - 어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있다.

* Content-Length는 서버 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때와 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요하다.

### 15.2.1 잘림 검출

* 옛날 버전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지했다.

* Content-Length가 없다면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 메시지 전송 중에 서버에 충돌이 발생한 것인지 구분하지 못한다.

* 클라이언트는 메시지 잘림을 검출하기 위해 Content-Length를 필요로 한다.

### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)

* Content-Length는 지속 커넥션을 위해 필수다.

* 만약 응답이 지속 커넥션을 통해서 온 것이라면, 또 다른 HTTP 응답이 즉시 그 뒤를 이을 것이다.

* Content-Length 헤더는 클라이언트에게 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려준다.

* 커넥션이 지속적이기 때문에, 클라이언트가 커넥션이 닫힌 위치를 근거로 메시지의 끝을 인식하는 것은 불가능하다.

* HTTP 어플리케이션은 Content-Length 헤더 없이는 어디까지가 엔터티 본문이고 어디부터가 다음 메시지인지 알 수 없을 것이다.

* 하지만 Content-Length 헤더 없이 지속 커넥션을 만날 수 있는 상황은 청크 인코딩을 사용할 때다.

### 15.2.4 콘텐츠 인코딩

* HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록, 엔터티 본문을 인코딩할 수 있게 해준다.

## 15.3 엔터티 요약

* HTTP가 일반적으로 TCP/IP와 같이 신뢰할 만한 전송 프로토콜 위애ㅔ서 구현됨에도 불구하고,  
불완전한 트랜스코딩 프락시나 버그 많은 중개자 프락시를 비롯한 여러 가지 이유로 메시지의 일부분이 전송 중에 변형되는 일이 일어난다.

* 엔터티 본문 데이터에 대한 의도하지 않은 변경을 감지하기 위해,  
최초 엔터티가 생성될 떄 송신자는 데이터에 대한 체크섬을 생성할 수 있으며,  
수신자는 모든 의도하지 않은 엔터티의 변경을 잡아내기 위해 그 체크섬으로 기본적인 검사를 할 수 있다.

* Content-MD5 헤더는 서버가 엔터티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용된다.

* 오직 응답을 처음 만든 서버만이 Content-MD5 헤더를 계산해서 보낼 것이다.

* 중간에 있는 프락시와 캐시는 그 헤더를 변경하거나 추가하지 않을 것이다.

* 그랬다간 종단 간 무결성을 검증하겠다는 목적을 손상시킬 것이기 때문이다.

* 메시지 무결성 검사에 더해, MD5는 문서의 위치를 빠르게 알아내고 콘테츠의 중복 저장을 방지하기 위한 해시 테이블의 키로 이용될 수 있다.

## 15.4 미디어 타입과 차셋(Charset)

* Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다.

* MIME 타입은 전달되는 데이터 매체의 기저 형식의 표준화된 이름이다.

* 클라이언트 애플리케이션은 콘텐츠를 적절히 해독하고 처리하기 위해 MIME 타입을 이용한다.

* MIME 타입은 빗금(/)을 기준으로 주 미디어 타입, 부 타입으로 구성된다.

* 다음 표 15-1은 Content-Type 헤더에서 흔히 쓰이는 MIME 타입을 몇 가지 나열한 것이다.

미디어타입 | 설명
---|---
text/html|엔터티 본문은 HTML 문서
text/plain|엔터티 본문은 플레인 텍스트 문서
image/gif|엔터티 본문은 GIF 이미지
image/jpeg|엔터티 본문은 JPEG 이미지
audio/x-wav|엔터티 본문은 WAV 음향 데이터를 포함
model/vrml|엔터티 본문은 삼차원 VRML 모델
application/vnd.ms-powerpoint|엔터티 본문은 마이크로소프트 파워포인트 프레젠테이션
multipart/byteranges|엔터티 본문은 여러 부분으로 나뉘는데, 각 부분은 전체 문서의 특정 범위(바이트 단위)를 담고 있다.
message/http|엔터티 본문은 완전한 HTTP 메시지를 담고 있다.

### 15.4.1 텍스트 매체를 위한 문자 인코딩

* Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원한다.

* 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 'charset' 매개변수가 그 대표적인 예이다.

    ```
    Content-Type: text/html; charset=iso-8859-4
    ```

## 15.5 콘텐츠 인코딩

* HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩을 하려고 한다.

    * 예를 들어, 느린 속도로 연결된 클라이언트에게 큰 HTML 문서를 전송하기 전에 서버는 전송 시간을 줄이기 위해 압축을 할 수 있다.

    * 서버는 허가받지 않은 제삼자가 볼 수 없도록 콘텐츠를 암호화하거나 뒤섞어서 보낼 수도 있다.

* 이러한 종류의 인코딩은 발송하는 쪽에서 콘텐츠에 적용한다.

* 콘텐츠 인코딩이 끝난 데이터는 늘 그렇듯 엔터티 본문에 담아 수신자에게 보낸다.

### 15.5.1 콘텐츠 인코딩 과정

* 콘텐츠 인고딩 과정은 다음과 같다.

1. 웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성한다.

2. 콘텐츠 인코딩 서버가 인코딩된 메시지를 생성한다.
    - 인코딩된 메시지는 Content-Type은 같지만 Content-Length는 다르다.
    - 콘텐츠 인코딩 서버는 Content-Encoding 헤더를 인코딩된 메시지에 추가하여, 수신 측 애플리케이션이 그것을 디코딩할 수 있도록 한다.

3. 수신 측 프로그램은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.

* 그림 15-3 : 콘텐츠 인코딩의 예

    <img src = images/15/example_03.png>

### 15.5.2 콘텐츠 인코딩 유형

* HTTP는 몇 가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용한다.

* 인코딩은 각 콘텐츠 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화 된다.

* Content-Encoding 헤더는 이러한 표준화된 토큰 값을 이용해서, 인코딩에 사용된 알고리즘들에 대해 기술한다.

* 표 15-2 : 콘텐츠 인코딩 토큰들

콘텐츠 인코딩 값 | 설명
---|---
gzip|엔터티에 GNU zip 인코딩이 적용되었음을 의미한다.
compress|엔터티에 대해 유닉스 파일 압축 프로그램인 'compress'가 실행되었음을 의미한다.
deflate|엔터티가 zlib 포맷으로 압축되었음을 의미한다.
identity|엔터티에 어떤 인코딩도 수행되지 않았음을 의미한다.

* 이 중 gzip은 일반적으로 가장 효율적이고 가장 널리 쓰이는 압축 알고리즘이다.

### 15.5.3 Accept-Encoding 헤더

* 서버에서 클라이언트가 지원하지 않는 인코딩을 사용하는 것을 막기 위해, 클라이언트는 자신이 지원하는 인코딩의 목록을 Accept-Encoding 요청 헤더를 통해 전달 한다.

* 그림 15-4 : HTTP 트랜잭션에서 Accept-Encoding을 사용하는 예

    <img src = images/15/example_04.png>

## 15.6 전송 인코딩과 청크 인코딩

* 전송 인코딩는 엔터티 본문에 적용되는 가역적 변환이지만, 그들은 구조적인 이유 때문에 적용되는 것이며 콘텐츠의 포맷과는 독립적이다.

* 메시지 데이터가 네트워크를 통해 전송되는 방법을 바꾸기 위해 전송 인코딩을 메시지에 적용할 수 있다.

* 그림 15-5 : 콘텐츠 인코딩 대 전송 인코딩

    <img src = images/15/example_05.png>

### 15.6.1 안전한 전송

* 역사적으로, 전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 `안전한 전송`을 위해 존재했다.

* HTTP에서 전송된 메시지의 본문이 문제를 일으킬 수 있는 이유는 몇 가지 밖에 없다.

    1. 알수 없는 크기
        - 흔히 서버(몇몇 게이트웨이 애플리케이션, 콘텐츠 인코더)들은 메시지 본문의 최종 크기를 알기 전에 데이터의 전송을 시작하려고 한다.

        - HTTP는 데이터에 앞서 Content-Length 헤더를 요구하기 때문에,  
        몇몇 서버는 데이터의 끝을 알리는 특별한 종결 꼬리말을 포함시켜 전송 인코디으로 데이터를 보내려 시도한다.

    2. 보안
        - 공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 뒤섞어버리는 방법도 있다.

### 15.6.2 Transfer-Encoding 헤더

* 전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 단 두 개뿐이다.

1. Transfer-Encoding
    - 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려준다.

2. TE
    - 어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용한다.

### 15.6.3 청크 인코딩

* 청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼갠다.

* 서버는 각 청크를 순차적으로 보낸다.

* 청크 인코딩을 이용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없어진다.

* 본문이 동적으로 생성됨에 따라, 서버는 그중 일부를 버퍼에 담은 뒤 그 한 청크를 그것의 크기와 함께 보낼 수 있다.

* 본문 전체를 모두 보낼 때까지 이 단계를 반복한다.

* 청크 인코딩이 전송 인코딩의 한 형태이며 따라서 본문이 아닌 메시지의 속성임에 주목해야 한다.

* 그림 15-6 : 청크 인코딩된 메시지의 구조

    <img src = images/15/example_06.png>

### 15.6.4 콘텐츠와 전송 인코딩의 조합

* 콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.

* 그림 15-7

    <img src = images/15/example_04.png>
    
    <br>

    - 어떻게 송신자가 콘텐츠 인코딩을 사용해서 HTML 파일을 압축하고 그 청크 데이터를 전송 인코딩을 사용해서 전송하는지 묘사한다.

    - 수신자가 본문을 '재구축'하는 절차는 이와 순서가 반대다.


## 15.7 시간에 따라 바뀌는 인스턴스

* 웹 객체는 정적이지 않다.

* 같은 URL은 시간에 따라 다른 버전의 객체를 가리킬 수 있다.

* 그림 15-8 : 인스턴스는 시간에 따른 스냅숏이다.
    
    <img src = images/15/example_08.png>

    <br>

    - 이 그림에서 클라이언트는 같은 리소스를 여러 번 요청했지만, 시간이 흐름에 따라 리소스의 다른 인스턴스를 받게 된다.

    - a 와 b 시점에서는 인스턴스가 같았지만 c 시점에서 다른 인스턴스를 받게 된다.

* HTTP 프로토콜은 어떤 특정한 종류의 요청이나 응답을 다루는 방법들을 정의하는데, 이것은 `인스턴스 조작`이라 불리며 객체의 인스턴스에 작용한다.

* 이들 중 대표적인 두 가지가 `범위 요청`과 `델타 인코딩이`다.


## 15.9 범위 요청

* HTTP는 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해준다.

* 모든 서버가 범위 요청을 받아들일 수 있는 것은 아니지만 많은 경우 가능하다.

* 서버는 클라이언트에게 자신이 범위를 받아들일 수 있는지 응답에 Accept-Range 헤더를 포함시키는 방법으로 알려줄 수 있다.

    - 이 헤더의 값은 측정의 단위로, 주로 바이트이다.

* 그림 15-9 : 엔터티 범위 요청의 예

    <img src = images/15/example_09.png>

## 15.10 델타 인코딩

* 새 페이지 전체를 보내는 대신, 페이지에 대한 클라이언트의 사본에 대해 변경된 부분만을 서버가 보낸다면 클라이언트는 더 빨리 페이지를 얻을 수 있다.

* 델타 인코딩은 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적화하는, HTTP 프로토콜의 확장이다.

* 델타 인코딩은 일종의 인스턴스 조작이다. 왜냐하면 어떤 객체의 특정 인스턴스들에 대한 클라이언트와 서버 사이의 정보 교환에 의존하기 떄문이다.

* 그림 15-10 : 델타 인코딩의 메커니즘

    <img src = images/15/example_10.png>