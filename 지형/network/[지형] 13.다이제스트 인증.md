# 13장 다이제스트 인증

* 기본 인증은 편리하고 유연하지만 전혀 안전하지 않다.

* 기본 보안을 안전하게 이용하는 유일한 방법은 SSL과 결합해서 사용하는 것이다.

* 다이제스트 인증은 기본 인증과 호환되는 더 안전한 대체재로서 개발되었다.

## 13.1 다이제스트 인증의 개선점

* 다이제스트 인증은 기본 인증의 가장 심각한 결함을 수정한 또 다른 HTTP 인증 프로토콜이다.

* 다이제스트 인증의 특징
    
    - 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.

    - 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다.

    - 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능하다.

    - 그 외 몇몇 잘 알려진 형태의 공격을 막는다.

* 다이제스트 인증이 가능한 가장 안전한 프로토콜은 아니다. 안전한 HTTP 트랜잭션을 위한 많은 요구사항을 만족하지 못한다.
    - 요청과 응답의 나머지 부분에 대해서는 다른 누군가가 엿보는 것이 가능하다.

* 그러한 요구사항들에는 전송 계층 보안(TSL)과 보안 HTTP(HTTPS)가 더 적합한 프로토콜이다.

* 그러나 기본 인증을 대체하기 위해 설게된 다이제스트 인증은 기본 인증보다 훨씬 강력하다.

### 13.1.1 비밀번호를 안전하게 지키기 위해 요약 사용하기

* 다이제스트 인증의 좌우명은 "절대로 비밀번호를 네트워크를 통해 보내지 않는다" 이다.

* 클라이언트는 비밀번호를 비가역적으로 뒤섞은 '지문(fingerprint)' 혹은 '요약(digest)'을 보낸다.

* 클라이언트와 서버는 둘 다 비밀번호를 알고 있으므로, 서버는 클라이언트가 보낸 요약이 비밀번호에 알맞게 대응하는지 검사할 수 있다.

* 그림 13-1 : 다이제스트 인증의 동작 예시

    <img src = images/13/example_01.png>

    <br>

    1. 클라이언트가 보호된 문서를 요구한다.
    
    2. 서버는 클라이언트가 비밀번호를 알고 있음을 스스로 증명하여 신원을 인증하기 전까지 문서를 제공하는 것을 거부한다.  
    서버는 클라이언트에게 사용자 이름과 요약된 형태의 비밀번호를 요구한다.

    3. 클라이언트는 비밀번호의 요약을 전달하여 자신이 비밀번호를 알고 있음을 증명한다.  
    서버는 모든 사용자의 비밀번호를 알고 있으므로, 클라이언트가 제공한 요약과 서버가 스스로 계산한 요약이 일치하는지 비교하여 사용자가 비밀번호를 알고 있는지 확인할 수 있다.  
    비밀번호를 모르는 사람은 올바른 요약을 만들어 내기 쉽지 않을 것이다.

    4. 서버는 클라이언트가 제공한 요약과 서버가 내부적으로 계산한 요약을 비교한다. 일치하면 이는 클라이언트가 비밀번호를 알고있는 것이다.  
    이 요약 함수는 매우 긴 자릿수의 숫자를 만들어 낼 수 있도록 되어 있기 때문에 찍어서 맞추는 것은 불가능 하다.  
    서버가 일치 여부를 확인하면, 클라이언트에게 문서가 제공된다.  
    이 모든 과정에서 비밀번호는 결코 네트워크를 통해 전송되지 않는다.


### 13.1.2 단방향 요약

* 요약은 `정보 본문의 압축` 이다.

* 요약은 단방향 함수로 동작하고, 일반적으로 입력 가능한 무한 가지의 모든 입력값들을 유한한 범위의 압축으로 변환한다.

* 인기 있는 요약 함수 중 하나인 MD5는 임의의 바이트 배열을 원래 길이와 상관없이 128비트 요약으로 변환한다.
    - 128비트 = $2^{128}$ 혹은 약 $1,000,000,000, \cdots$ 가지의 서로 다른 압축이 만들어 질 수 있다.

* MD5 요약의 예시
    입력 | MD요약
    ---|---
    "Hi"|C1A5298F939E87E8F962A5EDFC206918

* 요약 함수는 보통 암호 체크섬 (cryptographic checksums) 으로 불리며, 단방향 해시 함수이거나 지문 함수(fingerprint function) 이다.

### 13.1.3 재전송 방지를 위한 난스(nonce) 사용

* 요약은 비밀번호 자체와 다름없기에 요약을 가로채서 서버로 몇 번이고 재전송할 수 있고, 이는 안전하지 않다.

* 이런 재전송 공격을 방지하기 위해서 서버는 클라이언트에게 `난스`라고 불리는 특별한, 그리고 자주 바뀌는 증표를 건네준다.

* 난스를 비밀번호에 섞으면 난스가 바뀔 때마다 요약도 바뀌게 만들어 준다.

* 난스는 WWW-Authenticate 인증요구에 담겨서 서버에서 클라이언트로 넘겨진다.

### 13.1.4 다이제스트 인증 핸드셰이크

* HTTP 다이제스트 인증 프로토콜은 기본 인증에서 사용하는 것과 비슷한 헤더를 사용하는, 강화된 버전의 인증이다.

* 기존 헤더에 몇몇 새 옵션이 추가되었고, 선택적인 헤더인 Authorization-Info 가 새로 추가되었다.

* 그림 13-2 : 다이제스트 인증 핸드셰이크

    <img src = images/13/example_02.png>

    <br>

    1. 서버는 난스 값을 계산한다.

    2. 서버는 난스를 Authenticate 인증요구 메시지를 담아, 서버가 지원하는 알고리즘 목록과 함께 클라이언트에 전송한다.

    3. 클라이언트는 알고리즘을 선택하고 비밀번호와 그 외 데이터에 대한 요약을 계산한다.

    4. 클라이언트는 Authorization 메시지에 요약을 담아 서버에게 돌려준다.  
    만약 클라이언트가 서버를 인증하길 원한다면 클라이언트 난스를 보낼 수 있다.

    5. 서버는 요약, 선택한 알고리즘, 그 외 보조 데이터들을 받고, 클라이언트가 했던 그대로 요약을 계산한다.  
    서버는 그 다음 자신이 계산한 요약과 네트워크로 전송되어 온 요약이 서로 같은지 확인한다.  
    만약 클라이언트가 대칭적으로 서버에게 클라이언트 난스를 갖고 인증을 요구했다면, 클라이언트 요약이 만들어진다.  
    또한 서버는 클라이언트가 미리 다음번 요약을 올바르게 생성할 수 있도록 다음번 난스를 미리 계산해서 클라이언트에게 넘겨줄 수도 있다.


* 그림 13-3 : 기본 인증 대 다이제스트 인증 문법
    <img src = images/13/example_03.png>

<br><br>


## 13.2 요약 계산

* 다이제스트 인증의 핵심은 공개된 정보, 비밀 정보, 시한부 난스 값을 조합한 단방향 요약이다.

### 13.2.1 요약 알고리즘 입력 데이터

* 요약은 다음 세 요소로부터 계산된다.

* 단방향 해시 함수 H(d) 와 요약 함수 KD(s,d). 여기서 s는 비밀(secret)을, d는 데이터(data)를 의미한다.

* 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리. A1 이라 칭한다.

* 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리. A2 라 칭한다.

* A1, A2 두 조각의 데이터는 요약을 생성하기 위해 H와 KD에 의해 처리된다.

### 13.2.2 H(d)와 KD(s,d) 알고리즘

* 다이제스트 인증은 여러 가지 요약 알고리즘을 선택할 수 있도록 지원한다.

* RFC 2617 에서 제안된 두 알고리즘은 MD5 와 MD5-sess(sess는 세션을 뜻함) 이며, 만약 알고리즘이 정해지지 않았다면 MD5가 기본값이다.

* MD5와 MD5-sess 중 어느 것이 사용되더라도, H 함수는 데이터의 MD5를 계산하고, KD요약 함수는 콜론으로 연결된 비밀데이터와 일반 데이터의 MD5를 계산한다.

* ```
    H(<데이터>) = MD5(<데이터>)
    KD(<비밀>,<데이터>) = H(연결(<비밀>;<데이터>))
    ```


### 13.2.3 보안 관련 데이터 (A1)

* A1으로 불리는 데이터 덩어리는 사용자 이름, 비밀번호, 보호 영역, 난스와 같은 비밀 보호 정보로 이루어져 있다.

* A1은 메시지 자체가 아닌 비밀 정보와만 관련되어 있다.

* A1은 H, KD, A2와 마찬가지로 요약을 계산하기 위해 사용된다.

* RFC 2617은 선택된 알고리즘에 따라 A1을 계산할 수 있는 두 가지 방법을 정의한다.

1. MD5
    - 모든 요청마다 단방향 해시를 실행한다.

    - A1은 사용자 이름, 영역, 비밀번호를 콜론으로 연결한 것이다.

    ```
    A1 = <사용자>:<영역>:<비밀번호>
    ```

2. MD5-sess
    - 사용자 이름, 영역, 비밀번호에 대한 해시를 계산한 결과 뒤에 현재 난스와 클라이언트 난스(c난스)를 붙인 것이 A1이 된다.

    - CPU를 많이 사용하는 해시 계산은 처음 WWW-Authenticate 핸드셰이크를 할 떄 단 한 번만 수행한다.

    ```
    A1 = MD5(<사용자>:<영역>:비밀번호):<난스>:<c난스>
    ```

### 13.2.4 메시지 관련 데이터 (A2)

* A2로 불리는 데이터 덩어리는 URL, 요청 메서드, 메시지 엔터티 본문과 같은 메시지 자체의 정보를 나타낸다.

* A2는 메서드, 리소스, 메시지의 위조를 방지하기 위해 사용된다.

* A2는 H, KD, A1 과 마찬가지로 요약을 계산하기 위해 사용된다.

* RFC 2617은 선택된 보호 수준(quality of protection, qop)에 따른 A2의 두 가지 사용법을 정의하고 있다.

1. HTTP 요청 메서드와 URL만 포함하는 것이다.
    - 이것은 기본값이기도 한 qop="auth" 일 때 사용된다.

    ```
    <요청 메서드>:<uri 지시자 값>
    ```

2. 메시지 무결성 검사를 제공하기 위해 메시지 엔터티 본문을 추가하는 것이다.
    - 이것은 qop="auth-int" 일 때 사용된다.

    ```
    <요청 메서드>:<uri 지시자 값>:H(<요청 메시지 본문>)
    ```

* 요청 메서드는 HTTP 요청 메서드다.

* uri 지시자 값은 요청줄에서 가져온 요청 URI 이다.
    - '*', 'absoluteURL', 'abs_path' 중 아무것이나 될 수 있지만 반드시 요청 URI와 일치해야 한다.
    
    - 특히, 요청 URI가 absoluteURL 이라면 uri 지시자 값도 반드시 absoluteURL 이어야 한다.

### 13.2.5 요약 알고리즘 전반

* RFC 2617 은 주어진 H,KD,A1,A2로 요약을 계산하는 두 가지 방법을 정의한다.

1. 첫 번째 방법은 예전 명세인 RFC 2069 와 호환을 염두에 둔 것으로, qop 옵션이 빠졌을 때 사용된다.
    
    - 비밀 정보와 난스가 붙은 메시지 데이터의 해시를 이용해 요약을 계산한다.

2. 두 번째 방법은 현대적이면서 보다 선호되는 접근법으로 난스 횟수 집계 및 대칭 인증의 지원을 포함한다.

    - 이 접근법은 qop가 'auth' 일 때와 'auth-int' 일 때 모두 사용된다.
    
    - 이것은 난스 횟수, qop, c난스 데이터를 요약에 추가한다.

### 13.2.6 다이제스트 인증 세션

* 어떤 보호 공간을 위해 WWW-Authenticate 인증 요구에 대한 클라이언트 응답은, 그 보호 공간에 대한 인증 세션을 시작하게 한다.
    - '보호 공간' 은 접근 중인 서버의 루트(canonical root) 와 영역의 결합으로 정의된다.

* 인증 세션은 클라이언트가 보호 공간의 다른 서버로부터 또 다른 WWW-Authenticate 인증요구를 받을 때까지 지속된다.

* 클라이언트는 사용자 이름, 비밀번호, 난스, 난스 횟수, 그리고 보호 공간 내 미래의 요청에 들어갈 Authorization 헤더를 만들기 위해 사용될 인증 세션과 연관된 알아보기 힘든 값을 기억해야 한다.

* 난스가 만료되면, 서버는 포함된 난스 값이 낡은 것일 수 있음을 감수하고 오래된 Authorization 헤더 정보를 받아들이는 것을 택할 수 있다.

* 아니면, 서버는 클라이언트가 다시 요청을 보내도록 새 난스 값과 함께 401 응답을 반환할 수도 있다.

* 이때 이 응답에 "stale=true"로 정의함으로써 서버는 클라이언트에게 사용자 이름과 비밀번호를 새로 입력하도록 창을 띄울 필요 없이 새 난스 값으로 요청을 다시 보내라고 말해줄 수 있다.

### 13.2.7 사전(preemptive) 인가

<img src = images/13/example_04.png>

<br>

* 그림 13 - 4 a
    - 일반적인 인증에서는, 각 요청은 트랜잭션이 완료되기 전에 요청/인증요구 사이클을 필요로 한다.

* 그림 13 - 4 b
    - 만약 클라리언트가 다음 난스가 무엇이 될지 미리 알고 있어서, 서버가 물어보기 전에 올바른 Authorization 헤더를 생성할 수 있다면, 이 요청/인증요구 사이클은 생략할 수 있다.

    - 만약 클라이언트가 요청 받기 전에 Authorization 헤더를 계산할 수 있다면 클라이언트는 요청 / 인증요구 단계를 거치지 않고 미리 Authorization 헤더를 서버에 제공한다.

* 다이제스트 인증에서의 사전 인가는 약간 더 복잡한데, 왜냐하면 난스 기술은 재전송 공격을 저지하기 위한 것이기 때문이다.

* 서버는 임의의 난스를 생성하기 때문에, 인증요구를 받디 전에는 클라이언트가 무엇이 올바른 Authorization 헤더인지 알 방법이 없다.

* 다이제스트 인증은 여러 안전한 기능을 유지하면서 사전 인가를 할 수 있는 몇 가지 방법을 제안한다.
    - 클라이언트가 새 WWW-Authenticate 인증요구를 기다리지 않고 올바른 난스를 취득할 수 있는 방법이 몇 가지 있다.

    1. 서버가 다음 난스를 Authentication-Info 성공 헤더에 담아서 미리 보낸다.

    2. 서버가 짧은 시간 동안 같은 난스를 재사용하는 것을 허용한다.

    3. 클라이언트와 서버가 동기화되어 있고 예측 가능한 난스 생성 알고리즘을 사용한다.


#### 1. 다음 난스 미리 생성하기

* 서버는 Authentication-Info 성공 헤더를 통해 다음 난스 값을 미리 제공할 수 있다.

* 서버는 인증이 성공했을 때 200OK 응답과 함께 이 헤더를 미리 보낸다.  
    -   ```
        Authentication-Info: nextnonce="<난스값>"
        ```

* 주어진 다음 난스로 클라이언트는 Authorization 헤더를 미리 만들어 둘 수 있다.

#### 2. 제한된 난스 재사용

* 연속된 난스를 미리 생성하는 것 외의 또 다른 방법은 난스를 제한적으로 재사용하는 것이다.

* 예를 들어 서버는 한 난스를 다섯 번 혹은 10초간 재사용하도록 허락할 수 있다.
    - 클라이언트는 난스를 미리 알 수 있으므로 자유롭게 Authorization 헤더와 함께 요청을 발행하여 파이프라이닝할 수 있다.

    - 난스가 결국 만료되면 서버는 서버에게 401 Unauthorized 인증요구를 보낼 것이다.

    - 이때 WWW-Authenticate:stale=true 지시어는 다음과 같이 설정된다.
        ```
        WWW-Authenticate: Digest
        realm="<영역 값>"
        nonce="<난스 값>"
        stale=ture
        ```

- 난스를 재사용하면 공격자의 재전송 공격이 성공하기 쉬워지므로 보안성이 감소된다.

- 난스 재사용의 수명은 '절대 재사용 안 함' 부터 '잠재적으로 오랫동안 재사용' 까지 통제 가능하기 때문에 취약점과 성능 간의 트레이드오프가 있을 수 있다.

#### 3. 동기화된 난스 생성

* 제3자가 쉽게 예측할 수 없는 공유된 비밀키에 기반하면서 클라이언트와 서버가 순차적으로 같은 난스를 생성할 수 있도록 시간적으로 동기화된 난스 생성 알고리즘을 사용하는 것도 가능하다.


### 13.2.8 난스 선택

* 난스의 내용은 불투명하고 구현 의존적이다. 그러나 성능 수준, 보안, 편의성은 현명한 선택에 달려있다.

* RFC 2617은 다음과 같은 가상의 난스 공식을 제안했다.
    ```
    BASE64(타임스탬프 H(타임스탬프":" ETag ":" 개인키))
    ```

    * 타임 스탬프 : 서버에서 생성된 시간 혹은 아무것이나 반복 불가능한 값
   
    * ETag : 요청된 엔터티에 대한 ETag 헤더값
   
    * 개인 키 :  서버만이 알고 있는 값

* 서버는 클라이언트 인증 헤더를 받은 뒤, 위의 공식에서 해시 부분을 재계산해보고 클라이언트 인증 헤더와 난스와 일치하지 않거나 타임스탬프가 오래되었다면 요청을 거절한다.
    - 이 방법에서 서버는 난스의 유효 기간을 제한할 수 있다.

* ETag를 포함하면 갱신된 리소스에 대한 재요청을 방지한다.

* 재전송 공격을 방지하기 위해, 어떤 구현은 이전에 사용된 난스나 요약을 받아들이지 않도록 결정할 수 있다.

* 혹은 POST 나 PUT 요청을 위해 일회성 난스나 요약을 사용하고, GET 요청을 위해 타임스탬프를 사용할 수도 있다.

### 13.2.9 상호 인증

* RFC 2617은 클라이언트가 서버를 인증할 수 있도록 다이제스트 인증을 확장했다.

* 이는 서버가 공유된 비밀 정보에 근거한 올바른 응답 요약을 생성할 수 있도록, 클라이언트 난스(c난스) 값을 제공함으로써 가능해진다.

* 이후 서버는 Authentication-Info 헤더를 통해 클라이언트에 전달한다.

* 이 상호 인증은 RCF 2617로 표준화 되었다. RFC 2069 와의 하위호환성을 고려해서 선택사항으로 남겨두긴 했지만, 보안이 상당히 개선되므로 현대적인 클라이언트와 웹 서버라면 반드시 구현할 것을 권한다.

* 또한 상호 인증은 qop 지시자가 존재할 때는 항상 수행하여야 하고, 없다면 수행하지 말아야한다.

## 13.3 보호 수준(Quality of Protection) 향상

* qop 필드는 요약 헤더의 세 가지 헤더 WWW-Autenticate, Authorization, Autentication-Info 에 모두 존재할 수 있다.

* qop 필드는 클라이언트와 서버가 어떤 보호 기법을 어느 정도 수준으로 사용할 것인지 협상할 수 있게 해준다.
    - 예를 들어, 몇몇 트랜잭션은 전송 속도가 크게 떨어지는 것을 감수하고서라도 메시지 본문의 무결성을 간단하게 검사하려고 할 수도 있다.

* 서버는 우선 WWW-Authenticate 헤더에 qop 옵션을 쉼표로 구분된 목록 형태로 내보낸다.  
그 후 클라이언트는 그 옵션들 중 지원할 수 있으면서 동시에 자신의 요구에도 맞는 것을 선택하고, 그것을 Authorization 헤더의 qop 필드에 담아 돌려준다.

* qop 사용이 선택사항이지만, 그건 오로지 오래된 RFC 2069 명세와의 호환성을 유지하기 위해서다.  
모든 현대적인 요약 구현은 qop 옵션을 지원해야한다.

* RFC 2617은 기본적으로 두 가지 초기 보호수준 값을 정의하고 있다.
    1. 인증을 의미하는 "auth"

    2. 인증 및 메시지 무결성 보호를 의미하는 "auth-int"


### 13.3.1 메시지 무결성 보호

* 무결성 보호가 적용되었을 때 (qop="auth-int") 계산되는 H(엔터티 본문)는, 메시지 본문의 해시가 아닌 엔터티 본문의 해시이다.

* 이것은 송신자에 의해 어떠한 전송 인코딩이 적용되기도 전에 먼저 계산되고 그 후 수신자에 의해 제거된다.

* 이것이 멀티파트 경계와 각 파트의 임베딩된 헤더를 포함한다는 것에 주의해야 한다.

### 13.3.2 다이제스트 인증 헤더

* 기본, 다이제스트 인증 프로토콜 양쪽 모두 WWW-Authenticate 헤더에 담겨 전달되는 인증요구와, Authrization 헤더에 담겨 전달되는 인가 응답을 포함한다.

* 다이제스트 인증은 여기에 선택적인 Authentication-Info 헤더를 추가했다.

* 이 헤더는 3단계 핸드셰이크를 완성하고 다음번 사용할 난스를 전달하기 위해 인증 성공 후에 전송된다.

## 13.4 실제 상황에 대한 고려

* 다이제스트 인증 작업을 할 때 고려해야 할 것이 몇 가지 있다.

### 13.4.1 다중 인증요구

* 서버는 한 리소스에 대해 여러 인증을 요구할 수 있다.

* 예를 들어 서버가 클라이언트의 능력을 모른다면, 서버는 기본 및 다이제스트 인증요구를 모두 보낼 것이다.

* 다중 인증요구에 직면했을 때, 클라이언트는 반드시 자신이 지원할 수 잇는 가장 강력한 인증 메커니즘을 선택해야 한다.

### 13.4.2 오류 처리

* 다이제스트 인증에서, 지시자나 그 값이 적절하지 않거나 요구된 지시자가 빠져 있는 경우 알맞은 응답은 400 Bad Request 이다.

* 요청의 요약이 맞지 않으면, 로그인이 실패했음을 기록해 두는 것이 좋다.

* 반복된 실패는 공격자가 비밀번호 추측을 시도하고 있음을 의미한다.

* 인증 서버는 반드시 'uri' 지시자가 가리키는 리소스가 요청줄에 명시된 리소스와 같음을 확인해야 한다.  
만약 다르다면 서버는 400 Bad Request 에러를 반환하는 것이 좋다.

### 13.4.3 보호 공간 (Protection Space)

* 영역 값은, 접근한 서버의 루트 URL과 결합되어, 보호 공간을 정의한다.

* 영역은 서버의 보호된 리소스들을 자신만의 인증 제도와 인가 데이터베이스 어느 한 쪽 혹은 양쪽 모두를 가진 보호 영역의 집합으로 분할 할 수 있도록 해준다.

* 영역 값은 일반적으로 원 서버에 의해 할당되는 문자열이며 인증 제도에 추가적인 의미를 더한다.
    - 인가 제도는 같지만 영역은 다른 다중 인증요구가 있을 수 있음에 주의해야 한다.

* 보호 공간은 어떤 자격이 자동으로 적용되는 영역을 결정한다.

* 이전 요청이 인가되면, 같은 자격은 인증 제도, 매개변수, 사용자 설정 중 한 가지 이상에 의해 정해진 시간 동안 재사용 될 것이다.

* 인증 제도에 별달리 정의된 것이 없다면, 하나의 보호 공간은 서버 밖으로 확장될 수 없다.

### 13.4.4 URI 다시 쓰기

* 다음의 예와 같이, 프락시는 가리키는 리소스의 변경 없이 구문만 고쳐서 URI를 다시 쓰기도 한다.
    
    - 호스트 명은 정규화되거나 IP 주소로 대체될 수 있다.

    - 문자들은 "%" escape 형식으로 대체될 수 있다.

    - 특정 원 서버로부터 가져오는 리소스에 영향을 주지 않는, 타입에 대한 추가 속성이 URI의 끝에 붙거나 중간에 삽입될 수 있다.

* 프락시가 URI를 변경할 수 있는 동시에 다이제스트 인증은 URI 값의 무결성을 검사하므로, 다이제스트 인증은 이러한 변경에 의해 실패할 수 있다.

### 13.4.5 캐시

* 어떤 공유 캐시가 Authorization 헤더를 포함한 요청과 그에 대한 응답을 받은 경우, 다음의 두 Cache-Control 지시자 중 하나가 응답에 존재하지 않는 한 다른 요청에 대해 그 응답을 반환해서는 안된다.

1. 만약 원 서버의 응답이 "must-revalidate" Cache-Control 지시자를 포함한 경우, 캐시는 그 응답의 엔터티를 다음 요청에 대한 응답을 위해 활용할 것이다.  
그러나 원 서버가 새 요청을 인증할 수 있도록, 우선 그 요청의 헤더를 이용해서 재검사를 수행해야 한다.

2. 만약 원 서버의 응답이 "public" Cache-Control 지시자를 포함한 경우, 응답 엔터티는 그 다음에 오는 임의의 요청에 대한 응답으로 반환될 수 있다.

## 13.5 보안에 대한 고려사항

* RFC 2617은 HTTP 인증 제도에 내재된 보안 위협의 일부를 정리하는 일을 해냈다. 이 절은 그 중 몇 가지를 설명한다.

### 13.5.1 헤더 부당 변경

* 헤더 부당 변경에 대해 항상 안전한 시스템을 제공하기 위해서, 양 종단 암호화나 헤더에 대한 디지털 서명이 필요할 것이다.

* 다이제스트 인증은 쉽게 조작할 수 없는 인증 제도를 제공하는 것에 초점을 맞추고 있으나 반드시 그 보호를 데이터에까지 확장하는 것은 아니다.

* 보호 수준에 대한 정보는 WWW-Authenticate 와 Authorization 헤더에만 담겨있다.

### 13.5.2 재전송 공격

* 재전송 공격이란 누군가 어떤 트랜잭션에서 엿들은 인증 자격을 다른 트랜잭션을 위해 사용하는 것을 말한다.

* 이 문제는 GET 요청에 대한 이슈이긴 하지만, POST와 PUT 요청에 대한 재전송 공격에 대해서도 항상 잘 동작하는 예방책을 필수적으로 가지고 있어야 한다.

* 이 문제를 완화시키는 방법 중 하나는 클라이언트의 IP 주소, 타임스탬프, 리소스의 ETag, 개인 서버 키에 대한 요약을 포함하는 난스를 서버가 생성하도록 하는 것이다.
    - 난스 생성 시 클라이언트의 IP를 사용하게 되면, 같은 사용자로부터의 요청이 다른 프락시를 통과하게 될 수도 있는 프락시 팜은 사용할 수 없게 된다.

    - 또한 IP 주소를 속이는 것도 그다지 어려운 일이 아니다.

* 재전송 공격을 완전히 피할 수 있는 한 방법은 매 트랜잭션마다 유일한 난스 값을 사용하는 것이다.

### 13.5.3 다중 인증 메커니즘

* 서버가 다중 인증 제도를 지원할 때, WWW-Authenticate 헤더를 통해 선택지를 제공할 것이다.

* 클라이언트에게 가장 강력한 인증 메커니즘을 선택해야 할 의무가 있는 것은 아니기 때문에, 결국 인증의 강도는 선택지 중 가장 약한 것과 같다고 봐야 한다.

* 이 문제를 피하기 위한 확실한 방법은 클라이언트가 언제나 가능한 한 가장 강력한 인증 제도를 선택하는 것이다.

### 13.5.4 사전(dictionary) 공격

* 사전 공격은 전형적인 비밀번호 추측 공격이다.

* 이 문제를 해결할 좋은 방법은, 크래킹하기 어렵도록 상대적으로 복잡한 비밀번호를 사용하는 것과 괜찮은 비밀번호 만료 정책 외에는 실질적으로 없다.

### 13.5.5 악의적인 프락시와 중간자 공격 (Man-in-the-Middle Attack)

* 많은 인터넷 트래픽이 오늘날 한 프락시에서 다른 프락시로 이동한다.

* 리다이렉션 기술과 차단 프락시의 도입으로 사용자는 그의 요청이 프락시를 통과한다는 것조차 눈치 채지 못하곤 한다.  
만약 이들 프락시 중하나가 악의적이거나 보안이 허술하다면 클라이언트는 중간자 공격에 취약한 상태가 될 가능성이 있다.
    - 이러한 공격은 엿듣기 공격일 수도 있고, 혹은 인증 제도 선택지를 모두 제거하고 기본 인증과 같이 가장 약한 인증 제도로 대체하는 것일 수도 있다.

* 이 문제를 해결할 좋은 방법은 없다. 가능한 해결책은 클라이언트가 사용자에게 인증의 강도를 시각적으로 보여주는 것, 클라이언트가 가능한 한 가장 강력한 인증을 선택하도록 설정하는 것 등이 있다.

* 그러나 가장 강한 인증 제도를 사용한다 해도, 클라이언트는 여전히 도청에 취약하다. 이런 공격을 방어할 유일한 실패하지 않는 방법은 SSL을 사용하는 것이다.

### 13.5.6 선택 평문 공격

* 다이제스트 인증을 사용하는 클라이언트는 응답을 생성하기 위해 서버가 제공한 난스를 사용한다.

* 그러나 만약 보안이 허술하거나 악의적인 프락시가 트래픽 중간에 끼어든다면, 그것은 어렵지 않게 클라이언트가 응답 게산을 하기 위한 난스를 제공할 수 있다.

* 응답을 계산하기 위해 알려진 키를 사용하는 것은 응답의 암호 해독을 쉽게 한다. 이것은 선택 평문 공격이라 불린다.

* 선택 평문 공격에는 몇 가지 변종이 있다.
    - 미리 계산된 사전 공격 : 사전 공격과 선택 평문 공격의 조합이다.

    - 자동화된 무차별 대입 공격 : 많은 컴퓨터를 동원해 주어진 범위에서 가능한 모든 비밀번호를 열거한다.

* 일반적으로, 이런 공격으로 인한 위협은 쉽게 방어할 수 있다.
    - 클라이언트가 서버에서 제공된 난스 대신 선택적인 c난스 지시자를 사용하여 응답을 생성할 수 있도록 설정하는 것이다.

### 13.5.7 비밀번호 저장

* 다이제스트 인증 메커니즘은 사용자 응답을 서버 내부에 저장된 것과 비교한다.

* 다이제스트 인증 비밀번호 파일이 유출되면 영역의 모든 문서는 즉각 공격자에게 노출된다.

* 이 문제를 완화하는 몇 가지 방법은 다음과 같다.

    - 비밀번호 파일이 평문으로 된 비밀번호를 포함하고 있다고 생각하고 안전하게 보호한다.

    - 영역 이름이 유일함을 보장하며, 비밀번호 파일이 유출되더라도 피해를 특정 영역으로 국소화한다.





